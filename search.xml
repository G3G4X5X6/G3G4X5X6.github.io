<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARP协议</title>
    <url>/2023/06/15/ARP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="协议解析"><a href="#协议解析" class="headerlink" title="协议解析"></a>协议解析</h2><p>ARP（Address Resolution Protocol）协议是一种用于在计算机网络中解析网络层地址（如IP地址）与物理地址（如MAC地址）之间映射关系的协议。在数据包从源主机发送到目标主机的过程中，需要将目标主机的网络层地址转换为物理地址，才能在链路层上进行数据传输。</p>
<span id="more"></span>

<p>ARP协议工作流程如下：</p>
<ol>
<li>源主机检查目标IP地址是否在本地网络，如果不在，则将数据包转发给默认网关。</li>
<li>源主机检查ARP缓存表中是否已经有目标IP地址对应的物理地址，如果有，则直接将数据包发送到目标主机的物理地址。</li>
<li>如果ARP缓存表中没有目标IP地址对应的物理地址，源主机就会发送一个ARP请求广播，请求目标主机回复自己的物理地址。</li>
<li>网络中所有的主机都会接收到这个ARP请求广播，但只有目标主机会回复自己的物理地址。</li>
<li>目标主机收到ARP请求后，会将自己的物理地址打包在ARP回复中发送给源主机。</li>
<li>源主机收到ARP回复后，将目标主机的IP地址和物理地址存储在ARP缓存表中，以便下一次发送数据包时可以直接使用。</li>
</ol>
<p>ARP协议是一个简单而重要的协议，它能够帮助网络中的主机快速地解析IP地址和物理地址之间的映射关系，从而实现数据包在局域网内的快速传输。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_arp_request</span>(<span class="params">source_ip, target_ip, interface</span>):</span><br><span class="line">    <span class="comment"># 构建 Ethernet 请求数据包</span></span><br><span class="line">    <span class="comment"># 广播地址</span></span><br><span class="line">    broadcast_bytes = <span class="string">b&#x27;\xff\xff\xff\xff\xff\xff&#x27;</span></span><br><span class="line">    <span class="comment"># 源 MAC 地址</span></span><br><span class="line">    src_mac_bytes = binascii.unhexlify(<span class="string">&#x27;00:50:56:c0:00:08&#x27;</span>.replace(<span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    ethernet_header = struct.pack(<span class="string">&quot;!6s6s2s&quot;</span>, broadcast_bytes, src_mac_bytes, <span class="string">b&#x27;\x08\x06&#x27;</span>)  <span class="comment"># ARP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建 ARP 请求数据包</span></span><br><span class="line">    source_ip = socket.inet_aton(source_ip)  <span class="comment"># 源IP地址</span></span><br><span class="line">    target_mac_bytes = <span class="string">b&#x27;\x00\x00\x00\x00\x00\x00&#x27;</span>  <span class="comment"># 目标 MAC 地址</span></span><br><span class="line">    target_ip = socket.inet_aton(target_ip)  <span class="comment"># 目标IP地址</span></span><br><span class="line"></span><br><span class="line">    arp_request = struct.pack(<span class="string">&#x27;!HHBBH6s4s6s4s&#x27;</span>,</span><br><span class="line">                              <span class="number">0x0001</span>,  <span class="comment"># 硬件类型：以太网</span></span><br><span class="line">                              <span class="number">0x0800</span>,  <span class="comment"># 协议类型：IPv4（表示发送方要映射的协议地址类型。对于IP地址，该值为0x0800。）</span></span><br><span class="line">                              <span class="number">6</span>,  <span class="comment"># 硬件地址长度：6字节</span></span><br><span class="line">                              <span class="number">4</span>,  <span class="comment"># 协议地址长度：4字节</span></span><br><span class="line">                              <span class="number">0x0001</span>,  <span class="comment"># 操作码：ARP请求</span></span><br><span class="line">                              src_mac_bytes,</span><br><span class="line">                              source_ip,</span><br><span class="line">                              target_mac_bytes,</span><br><span class="line">                              target_ip)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建原始套接字</span></span><br><span class="line">    <span class="comment"># 不可或缺：socket.htons(0x0806)，否则无法接受返回</span></span><br><span class="line">    raw_socket = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.htons(<span class="number">0x0806</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绑定指定的网络接口</span></span><br><span class="line">    raw_socket.bind((interface, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送ARP请求</span></span><br><span class="line">    raw_socket.send(ethernet_header + arp_request)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收并解析响应</span></span><br><span class="line">    response = raw_socket.recv(<span class="number">2048</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析响应数据包</span></span><br><span class="line">    _, _, _, _, _, _, _, _, sender_mac, sender_ip, target_mac, target_ip = struct.unpack(<span class="string">&#x27;!6s6s2sHHBBH6s4s6s4s&#x27;</span>,</span><br><span class="line">                                                                                         response)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印目标MAC地址</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Reply -&gt; IP: <span class="subst">&#123;socket.inet_ntoa(sender_ip)&#125;</span>  MAC: <span class="subst">&#123;<span class="string">&#x27;:&#x27;</span>.join(<span class="built_in">format</span>(x, <span class="string">&#x27;02x&#x27;</span>) <span class="keyword">for</span> x <span class="keyword">in</span> sender_mac)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭原始套接字</span></span><br><span class="line">    raw_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    src_ip = <span class="string">&#x27;172.16.66.1&#x27;</span>  <span class="comment"># 目标IP地址</span></span><br><span class="line">    dst_ip = <span class="string">&#x27;172.16.66.130&#x27;</span>  <span class="comment"># 目标IP地址</span></span><br><span class="line">    inter = <span class="string">&#x27;vmnet8&#x27;</span>  <span class="comment"># 网络接口名</span></span><br><span class="line"></span><br><span class="line">    send_arp_request(src_ip, dst_ip, inter)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TCP/IP协议</category>
      </categories>
      <tags>
        <tag>arp</tag>
        <tag>socket</tag>
        <tag>chatgpt</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust: 错误处理</title>
    <url>/2025/01/05/Rust-Error/</url>
    <content><![CDATA[<p>错误是软件中不可避免的事实，因此 Rust 具有许多功能来处理出现错误的情况。在许多情况下，Rust 要求您承认错误的可能性并在代码编译之前采取一些措施。此要求可确保您在将代码部署到生产环境之前发现错误并适当处理它们，从而使您的程序更加健壮！</p>
<p><strong>Rust 将错误分为两大类：</strong></p>
<ul>
<li>可恢复错误<ul>
<li>对于可恢复错误，它的类型为 <code>Result&lt;T, E&gt;</code></li>
</ul>
</li>
<li>不可恢复错误<ul>
<li><code>panic!</code> 当程序遇到不可恢复的错误时停止执行的宏。</li>
</ul>
</li>
</ul>
<p><strong>错误传播：<code>?</code></strong></p>
<span id="more"></span>

<h1 id="0x01-使用-panic-处理不可恢复错误"><a href="#0x01-使用-panic-处理不可恢复错误" class="headerlink" title="0x01. 使用 panic! 处理不可恢复错误"></a>0x01. 使用 <code>panic!</code> 处理不可恢复错误</h1><blockquote>
<p><strong>展开堆栈或中止以响应恐慌</strong></p>
<p>默认情况下，当发生恐慌时，程序会开始展开，这意味着 Rust 会回溯堆栈并清理它遇到的每个函数的数据。但是，回溯和清理工作非常繁重。因此，Rust 允许您选择立即中止的替代方案，这将结束程序而不进行清理。<br>如果您的项目需要使生成的二进制文件尽可能小，则可以通过在 <code>Cargo.toml</code> 文件中的相应 <code>[profile]</code> 部分中添加 <code>panic = &#39;abort&#39;</code>，从展开切换到在发生恐慌时中止。例如，如果您想在发布模式下在发生恐慌时中止，请添加以下内容：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>让我们尝试在一个简单的程序中调用 <code>panic!</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该程序时，你会看到如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling panic v0.1.0 (file:///projects/panic)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.25s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread <span class="string">&#x27;main&#x27;</span> panicked at src/main.rs:2:5:</span><br><span class="line">crash and burn</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="0x02-使用-Result-处理可恢复的错误"><a href="#0x02-使用-Result-处理可恢复的错误" class="headerlink" title="0x02. 使用 Result&lt;T, E&gt; 处理可恢复的错误"></a>0x02. 使用 <code>Result&lt;T, E&gt;</code> 处理可恢复的错误</h1><p>大多数错误并不严重到需要程序完全停止。有时，当某个函数失败时，其原因很容易解释和响应。例如，如果您尝试打开一个文件，并且由于该文件不存在而导致该操作失败，您可能希望创建该文件而不是终止该进程。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-错误处理"><a href="#2-1-错误处理" class="headerlink" title="2.1 错误处理"></a>2.1 错误处理</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;error:?&#125;&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-匹配不同的错误"><a href="#2-2-匹配不同的错误" class="headerlink" title="2.2 匹配不同的错误"></a>2.2 匹配不同的错误</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;e:?&#125;&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;other_error:?&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化错误处理</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;error:?&#125;&quot;</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;error:?&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-错误处理的快捷方式：unwrap-和-expect"><a href="#2-3-错误处理的快捷方式：unwrap-和-expect" class="headerlink" title="2.3 错误处理的快捷方式：unwrap 和 expect"></a>2.3 错误处理的快捷方式：<code>unwrap</code> 和 <code>expect</code></h2><p><strong><code>unwrap</code></strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们在没有 <code>hello.txt</code> 文件的情况下运行此代码，我们将看到来自 <code>unwrap</code> 方法发出的 <code>panic!</code> 调用的错误消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">thread <span class="string">&#x27;main&#x27;</span> panicked at src/main.rs:4:49:</span><br><span class="line">called `Result::unwrap()` on an `Err` value: Os &#123; code: 2, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>expect</code></strong><br><code>expect</code> 方法还允许我们选择 <code>panic!</code> 错误消息。使用 <code>expect</code> 而不是 <code>unwrap</code> 并提供良好的错误消息可以传达您的意图，并使追踪 <code>panic</code> 的来源更加容易。<code>expect</code> 的语法如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;hello.txt should be included in this project&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expect</code> 在调用 <code>panic!</code> 时使用的错误消息将是我们传递给 <code>expect</code> 的参数，而不是 <code>unwrap</code> 使用的默认 <code>panic!</code> 消息。它如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">thread <span class="string">&#x27;main&#x27;</span> panicked at src/main.rs:5:10:</span><br><span class="line">hello.txt should be included <span class="keyword">in</span> this project: Os &#123; code: 2, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-传播错误"><a href="#2-4-传播错误" class="headerlink" title="2.4 传播错误"></a>2.4 传播错误</h2><p>当函数的实现调用了可能会失败的某个函数时，您可以将错误返回给调用代码，以便它决定要做什么，而不是在函数本身中处理错误。这称为传播错误，并为调用代码提供更多控制权，其中可能有更多信息或逻辑来指示应如何处理错误，而不是在代码上下文中可用的信息或逻辑。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">username_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username_file</span> = <span class="keyword">match</span> username_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> username_file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(username),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-传播错误的快捷方式：-运算符"><a href="#2-4-1-传播错误的快捷方式：-运算符" class="headerlink" title="2.4.1 传播错误的快捷方式：? 运算符"></a>2.4.1 传播错误的快捷方式：<code>?</code> 运算符</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    username_file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(username)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-在哪里可以使用-运算符"><a href="#2-4-2-在哪里可以使用-运算符" class="headerlink" title="2.4.2 在哪里可以使用 ? 运算符"></a>2.4.2 在哪里可以使用 <code>?</code> 运算符</h3><p><code>?</code> 运算符只能在返回类型与 <code>?</code> 所用值兼容的函数中使用。这是因为 <code>?</code> 运算符被定义为提前从函数中返回一个值。</p>
<blockquote>
<p>是提前返回值，不是返回任意值</p>
</blockquote>
<p><strong>错误示例</strong><br>应该返回 <code>()</code>，但是 <code>?</code> 返回了 <code>Result</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确示例</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># example <span class="number">1</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">last_char_of_first_line</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">char</span>&gt; &#123;</span><br><span class="line">    text.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">next</span>()?.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">last</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>幸运的是，main</code> 函数也能返回 <code>Result&lt;(), E&gt;</code>。示例 9-12 的代码来自示例 9-10，但我们将 main 函数的返回类型改为 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>，并在末尾添加了返回值 <code>Ok(())</code>。此代码现在可以通过编译。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># example <span class="number">2</span></span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 main 函数返回 Result&lt;(), E&gt; 时，如果 main 返回 Ok(())，则可执行文件将以 0 值退出；如果 main 返回 Err 值，则可执行文件将以非零值退出。用 C 编写的可执行文件在退出时返回整数：成功退出的程序返回整数 0，出错的程序返回 0 以外的整数。Rust 还会从可执行文件中返回整数以兼容此约定。</p>
<h1 id="0x03-To-panic-or-Not-to-panic"><a href="#0x03-To-panic-or-Not-to-panic" class="headerlink" title="0x03. To panic! or Not to panic!"></a>0x03. To <code>panic!</code> or Not to <code>panic!</code></h1><p>那么你如何决定何时应该调用 <code>panic!</code> 以及何时应该返回 <code>Result</code>？当代码崩溃时，没有办法恢复。你可以针对任何错误情况调用 <code>panic!</code>，无论是否有可能恢复，但你代表调用代码决定这种情况是不可恢复的。当你选择返回 <code>Result</code> 值时，你为调用代码提供了选项。调用代码可以选择尝试以适合其情况的方式进行恢复，或者它可以决定在这种情况下 <code>Err</code> 值是不可恢复的，因此它可以调用 <code>panic!</code> 并将可恢复的错误变成不可恢复的错误。因此，当你定义可能失败的函数时，返回 <code>Result</code> 是一个很好的默认选择。</p>
<h2 id="3-1-调用-panic"><a href="#3-1-调用-panic" class="headerlink" title="3.1 调用 panic!"></a>3.1 调用 <code>panic!</code></h2><p><strong>示例、原型代码和测试</strong></p>
<ul>
<li>当您编写示例来说明某个概念时，同时包含强大的错误处理代码会使示例变得不那么清晰。</li>
<li>同样，在您准备好决定如何处理错误之前，unwrap 和 expect 方法在原型设计时非常方便。</li>
<li>如果测试中的方法调用失败，您会希望整个测试失败，即使该方法不是被测试的功能。因为 panic! 是将测试标记为失败的方式，所以调用 unwrap 或 expect 正是应该发生的事情。</li>
</ul>
<p><strong>你比编译器拥有更多信息的情况</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::IpAddr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span>: IpAddr = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    .<span class="title function_ invoke__">parse</span>()</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Hardcoded IP address should be valid&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust: 理解所有权</title>
    <url>/2024/12/16/Rust-Understanding-Ownership/</url>
    <content><![CDATA[<p>所有权是 Rust 最独特的功能，对语言的其余部分有着深远的影响。它使 Rust 能够在不需要垃圾收集器的情况下保证内存安全，因此了解所有权的工作原理非常重要。</p>
<span id="more"></span>

<h1 id="0x01-什么是所有权？"><a href="#0x01-什么是所有权？" class="headerlink" title="0x01. 什么是所有权？"></a>0x01. 什么是所有权？</h1><p>所有权是一组规则，用于控制 Rust 程序如何管理内存。</p>
<h1 id="0x02-所有权规则"><a href="#0x02-所有权规则" class="headerlink" title="0x02. 所有权规则"></a>0x02. 所有权规则</h1><ul>
<li>每个值都有一个所有者。</li>
<li>一次只能有一个所有者。</li>
<li>当所有者超出范围时，该值将被删除。</li>
</ul>
<h2 id="2-1-每个值都有一个所有者"><a href="#2-1-每个值都有一个所有者" class="headerlink" title="2.1 每个值都有一个所有者"></a>2.1 每个值都有一个所有者</h2><p>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者。</p>
<h2 id="2-2-所有者超出范围时，该值将被删除"><a href="#2-2-所有者超出范围时，该值将被删除" class="headerlink" title="2.2 所有者超出范围时，该值将被删除"></a>2.2 所有者超出范围时，该值将被删除</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s is not valid here, it’s not yet declared</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// s is valid from this point forward</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do stuff with s</span></span><br><span class="line">&#125;                      <span class="comment">// this scope is now over, and s is no longer valid</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此外，这还隐含着一种设计选择：Rust 永远不会自动创建数据的“深层”副本。因此，可以认为任何自动复制在运行时性能方面都是低成本的。</p>
</blockquote>
<h2 id="2-3-一次只能有一个所有者。（变量与数据的交互）"><a href="#2-3-一次只能有一个所有者。（变量与数据的交互）" class="headerlink" title="2.3 一次只能有一个所有者。（变量与数据的交互）"></a>2.3 一次只能有一个所有者。（变量与数据的交互）</h2><blockquote>
<p>String 由三部分组成：指向保存字符串内容的内存的指针、长度和容量。这组数据存储在栈上。字符串内容保存在堆上。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># 仅栈数据：复制</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; # <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x; # <span class="number">5</span></span><br><span class="line"></span><br><span class="line"># 所有权转移</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;                    </span><br></pre></td></tr></table></figure>

<h1 id="0x03-参数传递"><a href="#0x03-参数传递" class="headerlink" title="0x03. 参数传递"></a>0x03. 参数传递</h1><p>将值传递给函数的机制与将值赋给变量的机制类似。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s comes into scope</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s&#x27;s value moves into the function...</span></span><br><span class="line">                                    <span class="comment">// ... and so is no longer valid here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x comes into scope</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x would move into the function,</span></span><br><span class="line">                                    <span class="comment">// but i32 is Copy, so it&#x27;s okay to still</span></span><br><span class="line">                                    <span class="comment">// use x afterward</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// Here, x goes out of scope, then s. But because s&#x27;s value was moved, nothing</span></span><br><span class="line">  <span class="comment">// special happens.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string comes into scope</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;some_string&#125;&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// Here, some_string goes out of scope and `drop` is called. The backing</span></span><br><span class="line">  <span class="comment">// memory is freed.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer comes into scope</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;some_integer&#125;&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// Here, some_integer goes out of scope. Nothing special happens.</span></span><br></pre></td></tr></table></figure>

<h1 id="0x04-函数返回"><a href="#0x04-函数返回" class="headerlink" title="0x04. 函数返回"></a>0x04. 函数返回</h1><p>返回值也可以转移所有权。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership moves its return</span></span><br><span class="line">                                        <span class="comment">// value into s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 comes into scope</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 is moved into</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back, which also</span></span><br><span class="line">                                        <span class="comment">// moves its return value into s3</span></span><br><span class="line">&#125; <span class="comment">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span></span><br><span class="line">  <span class="comment">// happens. s1 goes out of scope and is dropped.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">// gives_ownership will move its</span></span><br><span class="line">                                             <span class="comment">// return value into the function</span></span><br><span class="line">                                             <span class="comment">// that calls it</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string comes into scope</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// some_string is returned and</span></span><br><span class="line">                                             <span class="comment">// moves out to the calling</span></span><br><span class="line">                                             <span class="comment">// function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function takes a String and returns one</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string comes into</span></span><br><span class="line">                                                      <span class="comment">// scope</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// a_string is returned and moves out to the calling function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Cargo 使用指南之代码组织管理</title>
    <url>/2024/12/14/Rust-Cargo-Workspace/</url>
    <content><![CDATA[<p>Cargo 是 Rust 软件包管理器。Cargo 可以下载 Rust 软件包的依赖项、编译软件包、制作可分发的软件包，并将它们上传到 Rust 社区的软件包注册中心（<a href="crates.io">Package Registry</a> ） 。</p>
<h1 id="0x01-快速上手"><a href="#0x01-快速上手" class="headerlink" title="0x01. 快速上手"></a>0x01. 快速上手</h1><h2 id="1-1-创建二进制项目"><a href="#1-1-创建二进制项目" class="headerlink" title="1.1 创建二进制项目"></a>1.1 创建二进制项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo new hello_world</span><br><span class="line"><span class="comment"># 等价于 cargo new hello_world --bin</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hello_world/</span><br><span class="line"><span class="comment"># 项目结构</span></span><br><span class="line">tree .</span><br><span class="line"><span class="comment"># .</span></span><br><span class="line"><span class="comment"># ├── Cargo.toml</span></span><br><span class="line"><span class="comment"># └── src</span></span><br><span class="line"><span class="comment">#     └── main.rs</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 2 directories, 2 files</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cat src/main.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">// cat Cargo.toml</span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_world&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行</span></span><br><span class="line">cargo run</span><br><span class="line"><span class="comment">#    Compiling hello_world v0.1.0 (/home/sec/rust-code/hello_world)</span></span><br><span class="line"><span class="comment">#     Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.74s</span></span><br><span class="line"><span class="comment">#      Running `target/debug/hello_world`</span></span><br><span class="line"><span class="comment"># Hello, world!</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-创建依赖库项目"><a href="#1-2-创建依赖库项目" class="headerlink" title="1.2 创建依赖库项目"></a>1.2 创建依赖库项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo new hello_world --lib</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hello_world/</span><br><span class="line"><span class="comment"># 项目结构</span></span><br><span class="line">tree .</span><br><span class="line"><span class="comment"># .</span></span><br><span class="line"><span class="comment"># ├── Cargo.toml</span></span><br><span class="line"><span class="comment"># └── src</span></span><br><span class="line"><span class="comment">#     └── lib.rs</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 2 directories, 2 files</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">u64</span>, right: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">// Cargo.toml</span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_world&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码测试</span></span><br><span class="line">cargo <span class="built_in">test</span></span><br><span class="line"><span class="comment">#    Compiling hello_world v0.1.0 (/home/sec/rust-code/hello_world)</span></span><br><span class="line"><span class="comment">#     Finished `test` profile [unoptimized + debuginfo] target(s) in 0.51s</span></span><br><span class="line"><span class="comment">#      Running unittests src/lib.rs (target/debug/deps/hello_world-75e6e3a0ae56ef19)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># running 1 test</span></span><br><span class="line"><span class="comment"># test tests::it_works ... ok</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#    Doc-tests hello_world</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># running 0 tests</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span></span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-下载项目并构建"><a href="#1-3-下载项目并构建" class="headerlink" title="1.3 下载项目并构建"></a>1.3 下载项目并构建</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/rust-lang/regex.git</span><br><span class="line"><span class="comment"># Cloning into &#x27;regex&#x27;...</span></span><br><span class="line"><span class="comment"># remote: Enumerating objects: 9712, done.</span></span><br><span class="line"><span class="comment"># remote: Counting objects: 100% (3776/3776), done.</span></span><br><span class="line"><span class="comment"># remote: Compressing objects: 100% (1345/1345), done.</span></span><br><span class="line"><span class="comment"># remote: Total 9712 (delta 2492), reused 3367 (delta 2373), pack-reused 5936 (from 1)</span></span><br><span class="line"><span class="comment"># Receiving objects: 100% (9712/9712), 8.03 MiB | 816.00 KiB/s, done.</span></span><br><span class="line"><span class="comment"># Resolving deltas: 100% (6364/6364), done.</span></span><br><span class="line"><span class="built_in">cd</span> regex</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建</span></span><br><span class="line">cargo build</span><br><span class="line"><span class="comment">#     Updating `rsproxy-sparse` index</span></span><br><span class="line"><span class="comment">#      Locking 54 packages to latest compatible versions</span></span><br><span class="line"><span class="comment">#       Adding env_logger v0.9.3 (available: v0.11.5)</span></span><br><span class="line"><span class="comment">#    Compiling memchr v2.7.4</span></span><br><span class="line"><span class="comment">#    Compiling regex-syntax v0.8.5 (/home/sec/rust-code/regex/regex-syntax)</span></span><br><span class="line"><span class="comment">#    Compiling aho-corasick v1.1.3</span></span><br><span class="line"><span class="comment">#    Compiling regex-automata v0.4.9 (/home/sec/rust-code/regex/regex-automata)</span></span><br><span class="line"><span class="comment">#    Compiling regex v1.11.1 (/home/sec/rust-code/regex)</span></span><br><span class="line"><span class="comment">#     Finished `dev` profile [optimized + debuginfo] target(s) in 7.13s</span></span><br></pre></td></tr></table></figure>

<h1 id="0x02-核心概念"><a href="#0x02-核心概念" class="headerlink" title="0x02. 核心概念"></a>0x02. 核心概念</h1><h2 id="2-1-Module"><a href="#2-1-Module" class="headerlink" title="2.1 Module"></a>2.1 Module</h2><ul>
<li>模块(Module)：可以用来将代码分层地拆分为逻辑单元（模块），并管理它们之间的可见性（公共&#x2F;私有）</li>
<li>模块中包含：函数、结构、特征、实现块，甚至其他模块。</li>
<li>一个文件可以多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的<strong>代码组织单元</strong></li>
</ul>
<h2 id="2-2-Crate"><a href="#2-2-Crate" class="headerlink" title="2.2 Crate"></a>2.2 Crate</h2><ul>
<li>板条箱 (Crate) 是 Rust 中的<strong>编译单元</strong>。</li>
</ul>
<h2 id="2-3-Package"><a href="#2-3-Package" class="headerlink" title="2.3  Package"></a>2.3  Package</h2><ul>
<li>包（package）是一个包含一个或多个 crate 的集合，用于提供一组功能。</li>
<li>一个包（package）包含一个 <code>Cargo.toml</code> 文件，该文件描述了如何构建这些 crate。</li>
<li>一个包（package）可以包含任意多个二进制 crate，但最多只能包含一个库 crate。</li>
<li>一个包（package）必须至少包含一个 crate，无论是库 crate 还是二进制 crate。</li>
</ul>
<h3 id="2-3-1-Package-目录布局"><a href="#2-3-1-Package-目录布局" class="headerlink" title="2.3.1 Package 目录布局"></a>2.3.1 Package 目录布局</h3><p>Cargo 使用约定来放置文件，以便轻松进入新的 Cargo Package</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src/</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   ├── main.rs</span><br><span class="line">│   └── bin/</span><br><span class="line">│       ├── named-executable.rs</span><br><span class="line">│       ├── another-executable.rs</span><br><span class="line">│       └── multi-file-executable/</span><br><span class="line">│           ├── main.rs</span><br><span class="line">│           └── some_module.rs</span><br><span class="line">├── benches/</span><br><span class="line">│   ├── large-input.rs</span><br><span class="line">│   └── multi-file-bench/</span><br><span class="line">│       ├── main.rs</span><br><span class="line">│       └── bench_module.rs</span><br><span class="line">├── examples/</span><br><span class="line">│   ├── simple.rs</span><br><span class="line">│   └── multi-file-example/</span><br><span class="line">│       ├── main.rs</span><br><span class="line">│       └── ex_module.rs</span><br><span class="line">└── tests/</span><br><span class="line">    ├── some-integration-tests.rs</span><br><span class="line">    └── multi-file-test/</span><br><span class="line">        ├── main.rs</span><br><span class="line">        └── test_module.rs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Cargo.toml</code> 和 <code>Cargo.lock</code> 存储在包的根目录中（包根目录）。</li>
<li>源代码放在 <code>src</code> 目录中。</li>
<li>默认库文件是 <code>src/lib.rs</code>。</li>
<li>默认可执行文件是 <code>src/main.rs</code>。<ul>
<li>其他可执行文件可以放在 <code>src/bin/</code> 中。</li>
</ul>
</li>
<li>基准测试放在 <code>benches</code> 目录中。</li>
<li>示例放在 <code>examples</code> 目录中。</li>
<li>集成测试放在 <code>tests</code> 目录中。</li>
</ul>
<h2 id="2-4-Workspace"><a href="#2-4-Workspace" class="headerlink" title="2.4 Workspace"></a>2.4 Workspace</h2><p>工作区(Workspace)是一个或多个包(Package)的集合，这些包称为工作区成员，它们一起进行管理。</p>
<h1 id="0x03-基础包管理"><a href="#0x03-基础包管理" class="headerlink" title="0x03. 基础包管理"></a>0x03. 基础包管理</h1><h2 id="3-1-包含一个-crate"><a href="#3-1-包含一个-crate" class="headerlink" title="3.1 包含一个 crate"></a>3.1 包含一个 crate</h2><ul>
<li>库 crate</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hello_world/</span><br><span class="line"><span class="comment"># 项目结构</span></span><br><span class="line">tree .</span><br><span class="line"><span class="comment"># .</span></span><br><span class="line"><span class="comment"># ├── Cargo.toml</span></span><br><span class="line"><span class="comment"># └── src</span></span><br><span class="line"><span class="comment">#     └── lib.rs</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 2 directories, 2 files</span></span><br></pre></td></tr></table></figure>

<ul>
<li>二进制 crate</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hello_world/</span><br><span class="line"><span class="comment"># 项目结构</span></span><br><span class="line">tree .</span><br><span class="line"><span class="comment"># .</span></span><br><span class="line"><span class="comment"># ├── Cargo.toml</span></span><br><span class="line"><span class="comment"># └── src</span></span><br><span class="line"><span class="comment">#     └── main.rs</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 2 directories, 2 files</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-包含多个-crate"><a href="#3-2-包含多个-crate" class="headerlink" title="3.2 包含多个 crate"></a>3.2 包含多个 crate</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建库crate</span></span><br><span class="line">cargo new mutil_crate --lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认可执行文件是 `src/main.rs`，其他可执行文件可以放在 `src/bin/` 中。</span></span><br><span class="line"><span class="comment"># 创建多个二进制crate</span></span><br><span class="line"><span class="built_in">mkdir</span> src/bin</span><br><span class="line">vim src/bin/main1.rs</span><br><span class="line">vim src/bin/main2.rs</span><br><span class="line"></span><br><span class="line"><span class="comment"># Package结构</span></span><br><span class="line">tree .</span><br><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── bin</span><br><span class="line">    │   ├── main1.rs</span><br><span class="line">    │   └── main2.rs</span><br><span class="line">    └── lib.rs</span><br><span class="line"></span><br><span class="line">3 directories, 4 files</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行指定二进制crate</span></span><br><span class="line">cargo run --bin main1</span><br><span class="line"><span class="comment">#    Compiling mutil_crate v0.1.0 (/home/sec/rust-code/mutil_crate)</span></span><br><span class="line"><span class="comment">#     Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s</span></span><br><span class="line"><span class="comment">#      Running `target/debug/main1`</span></span><br><span class="line"><span class="comment"># Hello, main1!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行库crate单元测试</span></span><br><span class="line">cargo <span class="built_in">test</span> --lib</span><br><span class="line"><span class="comment">#    Compiling mutil_crate v0.1.0 (/home/sec/rust-code/mutil_crate)</span></span><br><span class="line"><span class="comment">#     Finished `test` profile [unoptimized + debuginfo] target(s) in 0.27s</span></span><br><span class="line"><span class="comment">#      Running unittests src/lib.rs (target/debug/deps/mutil_crate-55531a037166be43)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># running 1 test</span></span><br><span class="line"><span class="comment"># test tests::it_works ... ok</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span></span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>

<h1 id="0x04-进阶工作空间"><a href="#0x04-进阶工作空间" class="headerlink" title="0x04. 进阶工作空间"></a>0x04. 进阶工作空间</h1><p>工作区是一个或多个包的集合，这些包称为工作区成员，它们一起进行管理。</p>
<h2 id="4-1-功能要点"><a href="#4-1-功能要点" class="headerlink" title="4.1 功能要点"></a>4.1 功能要点</h2><ul>
<li>通用命令可以在所有工作区成员中运行，例如 <code>cargo check --workspace</code>。</li>
<li>所有包共享一个位于工作区根目录中的通用 <code>Cargo.lock</code> 文件。</li>
<li>所有包共享一个通用输出目录，该目录默认为工作区根目录中名为 <code>target</code> 的目录。</li>
<li>共享包元数据，例如与 <code>workspace.package</code>。</li>
<li><code>Cargo.toml</code> 中的 <code>[patch]</code>、<code>[replace]</code> 和 <code>[profile.*]</code> 部分仅在根清单中被识别，并在成员包的清单中被忽略。</li>
</ul>
<h2 id="4-2-支持配置"><a href="#4-2-支持配置" class="headerlink" title="4.2 支持配置"></a>4.2 支持配置</h2><p>工作区的根 <code>Cargo.toml</code> 支持以下部分：</p>
<ul>
<li>[workspace] — 定义工作区。<ul>
<li>resolver — 设置要使用的依赖项解析器。</li>
<li>members — 工作区中要包含的软件包。</li>
<li>exclude — 从工作区中排除的软件包。</li>
<li>default-members — 未选择特定软件包时要操作的软件包。</li>
<li>package — 软件包中用于继承的键。</li>
<li>dependency — 软件包依赖项中用于继承的键。</li>
<li>lints — 软件包 lints 中用于继承的键。</li>
<li>metadata — 外部工具的额外设置。</li>
</ul>
</li>
<li>[patch] — 覆盖依赖项。</li>
<li>[replace] — 覆盖依赖项（已弃用）。</li>
<li>[profile] — 编译器设置和优化。</li>
</ul>
<h2 id="4-3-创建工作空间"><a href="#4-3-创建工作空间" class="headerlink" title="4.3 创建工作空间"></a>4.3 创建工作空间</h2><p>工作区至少必须有一个成员，要么是根包，要么是虚拟清单。</p>
<p>要创建工作区，请将 <code>[workspace]</code> 表添加到 <code>Cargo.toml</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[workspace]</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-1-有根-Package-的工作空间"><a href="#4-3-1-有根-Package-的工作空间" class="headerlink" title="4.3.1 有根 Package 的工作空间"></a>4.3.1 有根 Package 的工作空间</h3><p>如果在已经定义 <code>[package]</code> 的 <code>Cargo.toml</code> 中添加了 <code>[workspace]</code> 部分，则该包是工作区的根包。工作区根目录是工作区的 <code>Cargo.toml</code> 所在的目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[workspace]</span><br><span class="line"></span><br><span class="line">[package]</span><br><span class="line">name = <span class="string">&quot;hello_world&quot;</span> <span class="comment"># the name of the package</span></span><br><span class="line">version = <span class="string">&quot;0.1.0&quot;</span>    <span class="comment"># the current version, obeying semver</span></span><br><span class="line">authors = [<span class="string">&quot;Alice &lt;a@example.com&gt;&quot;</span>, <span class="string">&quot;Bob &lt;b@example.com&gt;&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-虚拟工作空间"><a href="#4-3-2-虚拟工作空间" class="headerlink" title="4.3.2 虚拟工作空间"></a>4.3.2 虚拟工作空间</h3><p>或者，可以创建一个包含 <code>[workspace]</code> 部分但不包含 <code>[package]</code> 部分的 <code>Cargo.toml</code> 文件。这称为虚拟清单。当没有“主”包或您希望将所有包组织在单独的目录中时，这通常很有用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># [PROJECT_DIR]/Cargo.toml</span></span><br><span class="line">[workspace]</span><br><span class="line">members = [<span class="string">&quot;hello_world&quot;</span>]</span><br><span class="line">resolver = <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># [PROJECT_DIR]/hello_world/Cargo.toml</span></span><br><span class="line">[package]</span><br><span class="line">name = <span class="string">&quot;hello_world&quot;</span> <span class="comment"># the name of the package</span></span><br><span class="line">version = <span class="string">&quot;0.1.0&quot;</span>    <span class="comment"># the current version, obeying semver</span></span><br><span class="line">edition = <span class="string">&quot;2021&quot;</span>     <span class="comment"># the edition, will have no effect on a resolver used in the workspace</span></span><br><span class="line">authors = [<span class="string">&quot;Alice &lt;a@example.com&gt;&quot;</span>, <span class="string">&quot;Bob &lt;b@example.com&gt;&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>必须在虚拟工作区中明确设置解析器，因为它们没有 <code>package.edition</code> 来从解析器版本推断它。</li>
<li>默认情况下，在工作区根目录中运行的命令将针对所有工作区成员运行，请参阅 <a href="https://doc.rust-lang.org/stable/cargo/reference/workspaces.html#the-default-members-field"><code>default-members</code></a>。</li>
</ul>
<h2 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h2><ol>
<li>创建工作空间就是在  <code>Cargo.toml</code> 中添加了 <code>[workspace]</code> 部分。</li>
<li>成员 <code>Package</code> 对 <code>Workspace</code> 的数据继承。</li>
<li><code>cargo</code> 通用命令可以对空间成员进行统一管理。</li>
<li>具体 <code>[workspace]</code> 部分配置，详情请查看官方指南： <a href="https://doc.rust-lang.org/stable/cargo/reference/workspaces.html#workspaces">Workspaces</a></li>
</ol>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Cargo</tag>
      </tags>
  </entry>
  <entry>
    <title>开发环境依赖组件容器化配置参考</title>
    <url>/2023/08/20/docker-compose4dev/</url>
    <content><![CDATA[<p>为避免开发时总是需要耗时搭建开发依赖的组件，因此维护一个 <code>docker-compose</code> 用于快速部署依赖组件环境</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>elasticsearch:8.8.0</li>
<li>kibana:8.8.0</li>
<li>redis:7.0.11</li>
<li>mysql:8</li>
<li>postgres:15</li>
<li>grafana-enterprise</li>
</ul>
<p>​	</p>
<span id="more"></span>



<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:8.8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch8</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.type=single-node</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ELASTIC_PASSWORD=&lt;Your_ELASTIC_PASSWORD&gt;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9200:9200&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">esdata:/usr/share/elasticsearch/data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/kibana/kibana:8.8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana8</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SERVER_NAME=kibana</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">XPACK_SECURITY_ENABLED=true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5601:5601&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kibanadata:/usr/share/kibana/data</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:7.0.11</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis7</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="comment"># 修改密码以及绑定地址</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">--requirepass</span> <span class="string">&quot;&lt;your_redis_pass&gt;&quot;</span> <span class="string">--bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redisdata:/data</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql8</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--default-authentication-plugin=caching_sha2_password</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&lt;root_pass&gt;</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">&lt;your_db&gt;</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">&lt;your_user&gt;</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">&lt;your_pass&gt;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line">      </span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:15</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">postgres15</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">database</span>       				<span class="comment"># 设置数据库名称</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">user</span>   					<span class="comment"># 设置数据库用户</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">PasswOrd</span>				<span class="comment"># 设置数据库密码</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres_data:/var/lib/postgresql/data</span> 	<span class="comment"># 数据持久化存储的路径</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5432:5432&quot;</span> 	<span class="comment"># 将容器的 5432 端口映射到宿主机的 5432 端口</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">grafana:</span> 	<span class="comment"># 默认账号密码: admin/admin</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana-enterprise</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">GF_INSTALL_PLUGINS=grafana-clock-panel</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;3000:3000&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">grafana-storage:/var/lib/grafana</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">esdata:</span></span><br><span class="line">  <span class="attr">kibanadata:</span></span><br><span class="line">  <span class="attr">redisdata:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br><span class="line">  <span class="attr">postgres_data:</span></span><br><span class="line">  <span class="attr">grafana-storage:</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust: 快速开始</title>
    <url>/2024/12/14/Rust-Getting-Started/</url>
    <content><![CDATA[<h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01. 安装"></a>0x01. 安装</h1><p>在 Rust 开发环境中，所有工具都安装到 <code>~/.cargo/bin</code> 目录中，您可以在此处找到 Rust 工具链，包括 <code>rustc</code>、<code>cargo</code> 和 <code>rustup</code>。</p>
<h2 id="1-1-Windows"><a href="#1-1-Windows" class="headerlink" title="1.1 Windows"></a>1.1 Windows</h2><ol>
<li>Using rustup (Recommended)</li>
</ol>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">去官方网站下载安装程序</a></li>
</ul>
<ol start="3">
<li>Windows Subsystem for Linux</li>
</ol>
<ul>
<li><code>curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></li>
</ul>
<span id="more"></span>

<h2 id="1-2-Linux-MacOS"><a href="#1-2-Linux-MacOS" class="headerlink" title="1.2 Linux &amp; MacOS"></a>1.2 Linux &amp; MacOS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure>

<h1 id="0x02-更新"><a href="#0x02-更新" class="headerlink" title="0x02. 更新"></a>0x02. 更新</h1><p>要更新 Rust，在终端执行以下命令即可更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rustup update</span><br></pre></td></tr></table></figure>

<h1 id="0x03-卸载"><a href="#0x03-卸载" class="headerlink" title="0x03. 卸载"></a>0x03. 卸载</h1><p>要卸载 Rust 和 rustup，在终端执行以下命令即可卸载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rustup self uninstall</span><br></pre></td></tr></table></figure>

<h1 id="0x04-检查安装是否成功"><a href="#0x04-检查安装是否成功" class="headerlink" title="0x04. 检查安装是否成功"></a>0x04. 检查安装是否成功</h1><p>检查是否正确安装了 Rust，可打开终端并输入下面这行，此时能看到最新发布的稳定版本的版本号、提交哈希值和提交日期：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustc -V</span><br><span class="line"><span class="comment"># rustc 1.83.0 (90b35a623 2024-11-26)</span></span><br><span class="line"></span><br><span class="line">cargo -V</span><br><span class="line"><span class="comment"># cargo 1.83.0 (5ffbef321 2024-10-29)</span></span><br></pre></td></tr></table></figure>

<h1 id="0x05-切换国内镜像源"><a href="#0x05-切换国内镜像源" class="headerlink" title="0x05. 切换国内镜像源"></a>0x05. 切换国内镜像源</h1><blockquote>
<p>由于国内拉取 crates.io 以及安装 Rust 会面临流量出境不稳定的问题，我们提供了一个国内镜像代理以帮助国内 Rust 生态发展，欢迎大家使用。（<a href="https://rsproxy.cn/#getStarted">rsproxy</a>）<br>——字节跳动</p>
</blockquote>
<h2 id="5-1-配置说明"><a href="#5-1-配置说明" class="headerlink" title="5.1 配置说明"></a>5.1 配置说明</h2><p>步骤一：设置 Rustup 镜像， 修改配置 ~&#x2F;.zshrc or ~&#x2F;.bashrc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export RUSTUP_DIST_SERVER=&quot;https://rsproxy.cn&quot;</span><br><span class="line">export RUSTUP_UPDATE_ROOT=&quot;https://rsproxy.cn/rustup&quot;</span><br></pre></td></tr></table></figure>

<p>步骤二：安装 Rust（请先完成步骤一的环境变量导入并 source rc 文件或重启终端生效）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://rsproxy.cn/rustup-init.sh | sh</span><br></pre></td></tr></table></figure>

<p>步骤三：设置 crates.io 镜像， 修改配置 ~&#x2F;.cargo&#x2F;config，已支持git协议和sparse协议，&gt;&#x3D;1.68 版本建议使用 sparse-index，速度更快。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">replace-with = &#x27;rsproxy-sparse&#x27;</span><br><span class="line">[source.rsproxy]</span><br><span class="line">registry = &quot;https://rsproxy.cn/crates.io-index&quot;</span><br><span class="line">[source.rsproxy-sparse]</span><br><span class="line">registry = &quot;sparse+https://rsproxy.cn/index/&quot;</span><br><span class="line">[registries.rsproxy]</span><br><span class="line">index = &quot;https://rsproxy.cn/crates.io-index&quot;</span><br><span class="line">[net]</span><br><span class="line">git-fetch-with-cli = true</span><br></pre></td></tr></table></figure>

<h1 id="0x06-本地文档"><a href="#0x06-本地文档" class="headerlink" title="0x06. 本地文档"></a>0x06. 本地文档</h1><p>Rust 的安装还包括文档的本地副本，以便您可以离线阅读。运行 <code>rustup doc</code> 即可在浏览器中打开本地文档。</p>
<h1 id="0x07-示例"><a href="#0x07-示例" class="headerlink" title="0x07. 示例"></a>0x07. 示例</h1><h2 id="7-1-创建项目目录"><a href="#7-1-创建项目目录" class="headerlink" title="7.1 创建项目目录"></a>7.1 创建项目目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> hello_world</span><br><span class="line"><span class="built_in">cd</span> hello_world</span><br></pre></td></tr></table></figure>

<h2 id="7-2-编写并运行Rust程序"><a href="#7-2-编写并运行Rust程序" class="headerlink" title="7.2 编写并运行Rust程序"></a>7.2 编写并运行Rust程序</h2><p>接下来，创建一个新的源文件并将其命名为 <code>main.rs</code>。Rust 文件始终以 <code>.rs</code> 扩展名结尾。如果文件名中使用多个单词，则惯例是使用下划线将它们分隔开。例如，使用 <code>hello_world.rs</code> 而不是 <code>helloworld.rs</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustc main.rs</span><br><span class="line">./main</span><br><span class="line"><span class="comment"># Hello, world!</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/12/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清除旧的文件</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态文件</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署GitPage</span></span><br><span class="line">hexo deploy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7 下安装 JDK</title>
    <url>/2023/09/01/setup-jdk/</url>
    <content><![CDATA[<h1 id="一、卸载系统自带的-OpenJDK"><a href="#一、卸载系统自带的-OpenJDK" class="headerlink" title="一、卸载系统自带的 OpenJDK"></a>一、卸载系统自带的 OpenJDK</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line">[root@docker ~]<span class="comment"># java -version</span></span><br><span class="line">openjdk version <span class="string">&quot;1.8.0_222&quot;</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_222-b10)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.222-b10, mixed mode) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">rpm -qa | grep openjdk | xargs rpm -e --nodeps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认</span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="二、下载解压"><a href="#二、下载解压" class="headerlink" title="二、下载解压"></a>二、下载解压</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://repo.huaweicloud.com/java/jdk/8u202-b08/jdk-8u202-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf ./jdk-8u202-linux-x64.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure>

<h1 id="三、配置环境变量"><a href="#三、配置环境变量" class="headerlink" title="三、配置环境变量"></a>三、配置环境变量</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Java Environment</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/jdk1.8.0_202</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre/lib/rt.jar:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib/dt.jar:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使环境变量文件生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h1 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">&quot;1.8.0_202&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_202-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>jdk</tag>
        <tag>pyspark</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7 下部署 PySpark 开发环境</title>
    <url>/2023/09/02/setup-pyspark/</url>
    <content><![CDATA[<h1 id="一、下载预编译包"><a href="#一、下载预编译包" class="headerlink" title="一、下载预编译包"></a>一、下载预编译包</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载页面</span></span><br><span class="line">https://spark.apache.org/downloads.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载地址</span></span><br><span class="line">https://dlcdn.apache.org/spark/spark-3.4.1/spark-3.4.1-bin-hadoop3.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># Spark Standalone Mode</span></span><br><span class="line">https://spark.apache.org/docs/latest/spark-standalone.html</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="二、配置环境变量"><a href="#二、配置环境变量" class="headerlink" title="二、配置环境变量"></a>二、配置环境变量</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 spark 的 sbin 目录下的 spark-config.sh 中添加JDK的路径</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/jdk1.8.0_202</span><br><span class="line"></span><br><span class="line"><span class="comment"># 避免报错：</span></span><br><span class="line"><span class="comment"># localhost:   JAVA_HOME is not set</span></span><br></pre></td></tr></table></figure>

<h1 id="三、开放端口"><a href="#三、开放端口" class="headerlink" title="三、开放端口"></a>三、开放端口</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=4040/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=8081/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载规则</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h1 id="四、启动"><a href="#四、启动" class="headerlink" title="四、启动"></a>四、启动</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./start-all.sh</span><br></pre></td></tr></table></figure>

<h1 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 Spark 的 bin 目录下执行：</span></span><br><span class="line">./run-example SparkPi 10 | grep <span class="string">&quot;Pi is roughly&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>pyspark</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust: 模式与匹配</title>
    <url>/2025/01/04/Rust-Pattern-Matching/</url>
    <content><![CDATA[<h1 id="0x01-模式"><a href="#0x01-模式" class="headerlink" title="0x01. 模式"></a>0x01. 模式</h1><p>模式是 Rust 中用于匹配复杂和简单类型的结构的特殊语法。将模式与匹配表达式和其他结构结合使用，可以更好地控制程序的控制流。模式由以下内容的组合组成：</p>
<ul>
<li>Literals</li>
<li>Destructured arrays, enums, structs, or tuples</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul>
<span id="more"></span>

<h1 id="0x02-match-控制流"><a href="#0x02-match-控制流" class="headerlink" title="0x02. match 控制流"></a>0x02. <code>match</code> 控制流</h1><p>Rust 有一个非常强大的控制流构造，称为 <code>match</code>，它允许您将一个值与一系列模式进行比较，然后根据模式匹配执行代码。模式可以由文字值、变量名、通配符和许多其他内容组成；</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> VALUE &#123;</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x03-if-let-简洁控制流"><a href="#0x03-if-let-简洁控制流" class="headerlink" title="0x03.  if let 简洁控制流"></a>0x03.  <code>if let</code> 简洁控制流</h1><p> <code>if let</code> 语法让你可以将 <code>if</code> 和 <code>let</code> 组合成一种更简洁的方式，以处理匹配一个模式的值而忽略其余的值。</p>
<p> <em><strong>使用 <code>match</code> 编写的代码</strong></em></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">match</span> config_max &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(max) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;max&#125;&quot;</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>使用 <code>if let</code> 以更短的方式编写代码</strong></em></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(max) = config_max &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;max&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>使用 <code>else</code> 匹配其余情况</strong></em></p>
<p>与 <code>else</code> 搭配的代码块与 <code>match</code> 表达式中与 <code>_</code> 情况搭配的代码块相同，这相当于 <code>if let</code> 和 <code>else</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">match</span> coin &#123;</span><br><span class="line">    Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;state:?&#125;!&quot;</span>),</span><br><span class="line">    _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;state:?&#125;!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>综合例子</strong></em></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">favorite_color</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_tuesday</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span>: <span class="type">Result</span>&lt;<span class="type">u8</span>, _&gt; = <span class="string">&quot;34&quot;</span>.<span class="title function_ invoke__">parse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(color) = favorite_color &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Using your favorite color, &#123;color&#125;, as the background&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> is_tuesday &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Tuesday is green day!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(age) = age &#123;</span><br><span class="line">        <span class="keyword">if</span> age &gt; <span class="number">30</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Using purple as the background color&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Using orange as the background color&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Using blue as the background color&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x04-while-let-条件循环"><a href="#0x04-while-let-条件循环" class="headerlink" title="0x04. while let 条件循环"></a>0x04. <code>while let</code> 条件循环</h1><p>与 if let 结构类似，while let 条件循环允许 while 循环在模式持续匹配时一直运行。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = stack.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;top&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x05-for-循环"><a href="#0x05-for-循环" class="headerlink" title="0x05. for 循环"></a>0x05. <code>for</code> 循环</h1><p>在 for 循环中，关键字 for 后面的值是模式。例如，在 for x in y 中，x 就是模式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;value&#125; is at index &#123;index&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用枚举方法调整迭代器，以便它生成一个值和该值的索引，并将其放入元组中。生成的第一个值是元组 (0, ‘a’)。当此值与模式 (index, value) 匹配时，index 将为 0，value 将为 ‘a’，打印输出的第一行。</p>
<h1 id="0x06-let-语句"><a href="#0x06-let-语句" class="headerlink" title="0x06. let 语句"></a>0x06. <code>let</code> 语句</h1><p>实际上，我们也在其他地方使用过模式，包括在 let 语句中。例如，考虑使用 let 进行以下简单的变量赋值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>每次使用这样的 let 语句时，您都在使用模式，尽管您可能没有意识到这一点！更正式地说，let 语句如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">PATTERN</span> = EXPRESSION;</span><br></pre></td></tr></table></figure>

<p>在 let x &#x3D; 5; 这样的语句中，如果 PATTERN 位置有一个变量名，那么变量名只是一种特别简单的模式形式。Rust 将表达式与模式进行比较，并为其找到的任何名称赋值。因此，在 let x &#x3D; 5; 示例中，x 是一个模式，其含义是“将此处匹配的内容绑定到变量 x”。因为名称 x 是整个模式，所以这个模式实际上意味着“将所有内容绑定到变量 x，无论其值是什么。”</p>
<p>为了更清楚地了解 let 的模式匹配方面，请考虑示例 18-4，它使用带有 let 的模式来解构元组。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y, z) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>在这里，我们将一个元组与一个模式进行匹配。Rust 将值 (1, 2, 3) 与模式 (x, y, z) 进行比较，发现值与模式匹配，因此 Rust 将 1 绑定到 x，将 2 绑定到 y，将 3 绑定到 z。您可以将这个元组模式视为在其中嵌套了三个单独的变量模式。</p>
<blockquote>
<p>错误示例：<br>错误地构造一个模式，其变量与元组中元素的数量不匹配。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="0x06-函数参数"><a href="#0x06-函数参数" class="headerlink" title="0x06. 函数参数"></a>0x06. 函数参数</h1><p>函数参数也可以是模式，还可以在闭包参数列表中以与函数参数列表中相同的方式使用模式。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_coordinates</span>(&amp;(x, y): &amp;(<span class="type">i32</span>, <span class="type">i32</span>)) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Current location: (&#123;x&#125;, &#123;y&#125;)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = (<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_coordinates</span>(&amp;point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x07-可反驳性：模式是否可能无法匹配"><a href="#0x07-可反驳性：模式是否可能无法匹配" class="headerlink" title="0x07. 可反驳性：模式是否可能无法匹配"></a>0x07. 可反驳性：模式是否可能无法匹配</h1><p>模式有两种形式：可反驳的和不可反驳的。</p>
<ul>
<li><strong>与任何可能传递的值相匹配的模式是不可反驳的。</strong><ul>
<li>例如，语句 let x &#x3D; 5; 中的 x因为 x 匹配任何内容，因此不可能匹配失败。</li>
</ul>
</li>
<li><strong>无法匹配某些可能值的模式是可反驳的。</strong><ul>
<li>例如，表达式 if let Some(x) &#x3D; a_value 中的 Some(x)，因为如果 a_value 变量中的值为 None 而不是 Some，则 Some(x) 模式将不匹配。</li>
</ul>
</li>
</ul>
<p><strong>函数参数、<code>let</code> 语句和 <code>for</code> 循环只能接受不可反驳的模式，因为当值不匹配时程序无法执行任何有意义的操作。</strong> <code>if let</code> 和 <code>while let</code> 表达式接受可反驳和不可反驳的模式，但编译器会警告不可反驳的模式，因为根据定义，它们旨在处理可能的失败：条件的功能在于其能够根据成功或失败执行不同的操作。</p>
<p>让我们看一个例子，看看当我们尝试使用可反驳的模式时会发生什么，而 Rust 需要不可反驳的模式，反之亦然。清单 18-8 显示了一个 let 语句，但对于模式我们指定了 Some(x)，这是一个可反驳的模式。正如您所料，这段代码将无法编译。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">Some</span>(x) = some_option_value;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling patterns v0.1.0 (file:///projects/patterns)</span><br><span class="line">error[E0005]: refutable pattern <span class="keyword">in</span> <span class="built_in">local</span> binding</span><br><span class="line"> --&gt; src/main.rs:3:9</span><br><span class="line">  |</span><br><span class="line">3 |     <span class="built_in">let</span> Some(x) = some_option_value;</span><br><span class="line">  |         ^^^^^^^ pattern `None` not covered</span><br><span class="line">  |</span><br><span class="line">  = note: `<span class="built_in">let</span>` bindings require an <span class="string">&quot;irrefutable pattern&quot;</span>, like a `struct` or an `enum` with only one variant</span><br><span class="line">  = note: <span class="keyword">for</span> more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html</span><br><span class="line">  = note: the matched value is of <span class="built_in">type</span> `Option&lt;i32&gt;`</span><br><span class="line"><span class="built_in">help</span>: you might want to use `<span class="built_in">let</span> <span class="keyword">else</span>` to handle the variant that isn<span class="string">&#x27;t matched</span></span><br><span class="line"><span class="string">  |</span></span><br><span class="line"><span class="string">3 |     let Some(x) = some_option_value else &#123; todo!() &#125;;</span></span><br><span class="line"><span class="string">  |                                     ++++++++++++++++</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information about this error, try `rustc --explain E0005`.</span></span><br><span class="line"><span class="string">error: could not compile `patterns` (bin &quot;patterns&quot;) due to 1 previous error</span></span><br></pre></td></tr></table></figure>

<p>因为我们没有用 Some(x) 模式覆盖（也无法覆盖！）每个有效值，Rust 理所当然地会产生编译器错误。</p>
<p>如果我们有一个需要不可反驳模式的可反驳模式，我们可以通过更改使用该模式的代码来修复它：我们可以使用 <code>if let</code>，而不是使用 <code>let</code>。然后，如果模式不匹配，代码将跳过大括号中的代码，从而有效地继续。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = some_option_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经给出了代码！该代码现在完全有效。但是，如果我们给出 <code>if let</code> 一个不可反驳的模式（始终匹配的模式），例如 x，编译器将给出警告。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling patterns v0.1.0 (file:///projects/patterns)</span><br><span class="line">warning: irrefutable `<span class="keyword">if</span> <span class="built_in">let</span>` pattern</span><br><span class="line"> --&gt; src/main.rs:2:8</span><br><span class="line">  |</span><br><span class="line">2 |     <span class="keyword">if</span> <span class="built_in">let</span> x = 5 &#123;</span><br><span class="line">  |        ^^^^^^^^^</span><br><span class="line">  |</span><br><span class="line">  = note: this pattern will always match, so the `<span class="keyword">if</span> <span class="built_in">let</span>` is useless</span><br><span class="line">  = <span class="built_in">help</span>: consider replacing the `<span class="keyword">if</span> <span class="built_in">let</span>` with a `<span class="built_in">let</span>`</span><br><span class="line">  = note: `<span class="comment">#[warn(irrefutable_let_patterns)]` on by default</span></span><br><span class="line"></span><br><span class="line">warning: `patterns` (bin <span class="string">&quot;patterns&quot;</span>) generated 1 warning</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.39s</span><br><span class="line">     Running `target/debug/patterns`</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p><strong>因此，匹配臂必须使用可反驳的模式，最后一个臂除外，它应该将任何剩余的值与不可反驳的模式相匹配。</strong> Rust 允许我们在只有一个分支的匹配中使用无可辩驳的模式，但这种语法并不是特别有用，可以用更简单的 <code>let</code> 语句替换。</p>
<h1 id="0x08-创建模式的所有语法"><a href="#0x08-创建模式的所有语法" class="headerlink" title="0x08. 创建模式的所有语法"></a>0x08. 创建模式的所有语法</h1><p><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html">创建模式的所有语法</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7 部署 OpenVPN</title>
    <url>/2023/10/29/setup-openvpn/</url>
    <content><![CDATA[<h2 id="0x01-环境安装"><a href="#0x01-环境安装" class="headerlink" title="0x01. 环境安装"></a>0x01. 环境安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新 CentOS 软件包</span></span><br><span class="line">yum -y update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 OpenVPN 和 EasyRSA</span></span><br><span class="line">yum -y install openvpn easy-rsa firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果未能成功安装 OpenVPN，则可能需要先安装一下 Epel 库</span></span><br><span class="line">yum install epel-release -y</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="0x02-证书生成"><a href="#0x02-证书生成" class="headerlink" title="0x02. 证书生成"></a>0x02. 证书生成</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先需要初始化 PKI ，会在当前目录生成 pki 目录</span></span><br><span class="line">/usr/share/easy-rsa/3/easyrsa init-pki</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来是生成 CA 证书，其中 nopass 表示不加密私钥，主要是方便后面导出公钥与颁发服务器证书</span></span><br><span class="line">/usr/share/easy-rsa/3/easyrsa build-ca nopass</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再来是生成交互密钥</span></span><br><span class="line">/usr/share/easy-rsa/3/easyrsa gen-dh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始生成服务端密钥</span></span><br><span class="line">/usr/share/easy-rsa/3/easyrsa build-server-full server nopass</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来生成客户端密钥，如果未开启同证书允许多人登陆，则需要多次执行生成对应的客户端密钥</span></span><br><span class="line">/usr/share/easy-rsa/3/easyrsa build-client-full client nopass</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后是生成证书交互列表，如果不需要 crl-verify 则可以跳过</span></span><br><span class="line">/usr/share/easy-rsa/3/easyrsa gen-crl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实到这一步需要的证书都以及生成好了，如果你开启了 tls-auth 则还需要生成共享密钥</span></span><br><span class="line">openvpn --genkey --secret pki/ta.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在上面所有证书都生成完毕之后</span></span><br><span class="line"><span class="comment"># 创建目录存放所有相关证书文件，方便后期管理（备份与恢复）</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 服务端配置所需证书文件</span></span><br><span class="line"><span class="built_in">mkdir</span> -p openvpn/server</span><br><span class="line"><span class="built_in">cp</span> pki/ca.crt openvpn/server/ca.crt</span><br><span class="line"><span class="built_in">cp</span> pki/dh.pem openvpn/server/dh.pem</span><br><span class="line"><span class="built_in">cp</span> pki/issued/server.crt openvpn/server/server.crt</span><br><span class="line"><span class="built_in">cp</span> pki/private/server.key openvpn/server/server.key</span><br><span class="line"><span class="built_in">cp</span> pki/ta.key openvpn/server/ta.key</span><br><span class="line"><span class="built_in">cp</span> pki/crl.pem openvpn/server/crl.pem</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 客户端配置所需证书文件</span></span><br><span class="line"><span class="built_in">mkdir</span> -p openvpn/client</span><br><span class="line"><span class="built_in">cp</span> pki/ca.crt openvpn/client/ca.crt</span><br><span class="line"><span class="built_in">cp</span> pki/issued/client.crt openvpn/client/client.crt</span><br><span class="line"><span class="built_in">cp</span> pki/private/client.key openvpn/client/client.key</span><br><span class="line"><span class="built_in">cp</span> pki/ta.key openvpn/client/ta.key</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="0x03-服务端配置"><a href="#0x03-服务端配置" class="headerlink" title="0x03. 服务端配置"></a>0x03. 服务端配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制官方服务端配置样例</span></span><br><span class="line"><span class="built_in">cp</span> /usr/share/doc/openvpn-2.4.12/sample/sample-config-files/server.conf openvpn/server/server.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#############################################################</span></span><br><span class="line"><span class="comment"># 以下为修改配置文件内容</span></span><br><span class="line"><span class="comment">#############################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SSL/TLS root certificate (ca), certificate</span></span><br><span class="line"><span class="comment"># (cert), and private key (key).  Each client</span></span><br><span class="line"><span class="comment"># and the server must have their own cert and</span></span><br><span class="line"><span class="comment"># key file.  The server and all clients will</span></span><br><span class="line"><span class="comment"># use the same ca file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See the &quot;easy-rsa&quot; directory for a series</span></span><br><span class="line"><span class="comment"># of scripts for generating RSA certificates</span></span><br><span class="line"><span class="comment"># and private keys.  Remember to use</span></span><br><span class="line"><span class="comment"># a unique Common Name for the server</span></span><br><span class="line"><span class="comment"># and each of the client certificates.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Any X509 key management system can be used.</span></span><br><span class="line"><span class="comment"># OpenVPN can also use a PKCS #12 formatted key file</span></span><br><span class="line"><span class="comment"># (see &quot;pkcs12&quot; directive in man page).</span></span><br><span class="line">ca ca.crt</span><br><span class="line">cert server.crt</span><br><span class="line">key server.key  <span class="comment"># This file should be kept secret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Diffie hellman parameters.</span></span><br><span class="line"><span class="comment"># Generate your own with:</span></span><br><span class="line"><span class="comment">#   openssl dhparam -out dh2048.pem 2048</span></span><br><span class="line">dh dh.pem </span><br><span class="line"><span class="comment"># 以上配置内容修改为证书生成所对应的文件名及路径，服务端识别的相对路径为 `/etc/openvpn`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Push routes to the client to allow it</span></span><br><span class="line"><span class="comment"># to reach other private subnets behind</span></span><br><span class="line"><span class="comment"># the server.  Remember that these</span></span><br><span class="line"><span class="comment"># private subnets will also need</span></span><br><span class="line"><span class="comment"># to know to route the OpenVPN client</span></span><br><span class="line"><span class="comment"># address pool (10.8.0.0/255.255.255.0)</span></span><br><span class="line"><span class="comment"># back to the OpenVPN server.</span></span><br><span class="line">push <span class="string">&quot;route 172.16.1.0 255.255.255.0&quot;</span></span><br><span class="line">push <span class="string">&quot;route 192.168.1.0 255.255.255.0&quot;</span></span><br><span class="line"><span class="comment"># 推送路由信息给客户端以找到 VPN 背后的子网</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Select a cryptographic cipher.</span></span><br><span class="line"><span class="comment"># This config item must be copied to</span></span><br><span class="line"><span class="comment"># the client config file as well.</span></span><br><span class="line"><span class="comment"># Note that v2.4 client/server will automatically</span></span><br><span class="line"><span class="comment"># negotiate AES-256-GCM in TLS mode.</span></span><br><span class="line"><span class="comment"># See also the ncp-cipher option in the manpage</span></span><br><span class="line">cipher AES-256-GCM <span class="comment"># 原：AES-256-CBC</span></span><br><span class="line"><span class="comment"># 修改为安全性更高的加密方式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后追加（可选）</span></span><br><span class="line">crl-verify crl.pem</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="0x04-客户端配置"><a href="#0x04-客户端配置" class="headerlink" title="0x04. 客户端配置"></a>0x04. 客户端配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复杂官方客户端配置样例</span></span><br><span class="line"><span class="built_in">cp</span> /usr/share/doc/openvpn-2.4.12/sample/sample-config-files/client.conf openvpn/client/client.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#############################################################</span></span><br><span class="line"><span class="comment"># 以下为修改配置文件内容</span></span><br><span class="line"><span class="comment">#############################################################</span></span><br><span class="line"><span class="comment"># The hostname/IP and port of the server.</span></span><br><span class="line"><span class="comment"># You can have multiple remote entries</span></span><br><span class="line"><span class="comment"># to load balance between the servers.</span></span><br><span class="line">remote my-server-1 1194</span><br><span class="line">;remote my-server-2 1194</span><br><span class="line"><span class="comment"># 修改服务器监听地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SSL/TLS parms.</span></span><br><span class="line"><span class="comment"># See the server config file for more</span></span><br><span class="line"><span class="comment"># description.  It&#x27;s best to use</span></span><br><span class="line"><span class="comment"># a separate .crt/.key file pair</span></span><br><span class="line"><span class="comment"># for each client.  A single ca</span></span><br><span class="line"><span class="comment"># file can be used for all clients.</span></span><br><span class="line">ca ca.crt</span><br><span class="line">cert client.crt</span><br><span class="line">key client.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># If a tls-auth key is used on the server</span></span><br><span class="line"><span class="comment"># then every client must also have the key.</span></span><br><span class="line">tls-auth ta.key 1</span><br><span class="line"><span class="comment"># 以上配置内容修改为文件所对应路径，证书文件与配置文件在同一目录下即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Select a cryptographic cipher.</span></span><br><span class="line"><span class="comment"># If the cipher option is used on the server</span></span><br><span class="line"><span class="comment"># then you must also specify it here.</span></span><br><span class="line"><span class="comment"># Note that v2.4 client/server will automatically</span></span><br><span class="line"><span class="comment"># negotiate AES-256-GCM in TLS mode.</span></span><br><span class="line"><span class="comment"># See also the ncp-cipher option in the manpage</span></span><br><span class="line">cipher AES-256-GCM</span><br><span class="line"><span class="comment"># 修改加密方式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="0x05-启动服务端并让其开机自动启动"><a href="#0x05-启动服务端并让其开机自动启动" class="headerlink" title="0x05. 启动服务端并让其开机自动启动"></a>0x05. 启动服务端并让其开机自动启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start openvpn@server</span><br><span class="line">systemctl <span class="built_in">enable</span> openvpn@server</span><br></pre></td></tr></table></figure>

<h2 id="0x06-配置防火墙与流量转发"><a href="#0x06-配置防火墙与流量转发" class="headerlink" title="0x06. 配置防火墙与流量转发"></a>0x06. 配置防火墙与流量转发</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置防火墙与流量转发</span></span><br><span class="line">firewall-cmd --permanent --add-service openvpn</span><br><span class="line">firewall-cmd --permanent --add-masquerade</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否开启流量转发</span></span><br><span class="line">sysctl -a | grep net.ipv4.ip_forward</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保net.ipv4.ip_forward 等于 1，如果不是，则需要修改一下</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h2 id="0x07-合并证书到配置文件中"><a href="#0x07-合并证书到配置文件中" class="headerlink" title="0x07. 合并证书到配置文件中"></a>0x07. 合并证书到配置文件中</h2><p>编辑client.ovpn客户端配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim client.ovpn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除或者注释以下几行内容：</span></span><br><span class="line">ca ca.crt　　   改为：<span class="comment">#ca ca.crt</span></span><br><span class="line">cert client.crt　　 改为：<span class="comment">#cert client.crt</span></span><br><span class="line">key client.key　　 改为：<span class="comment">#key client.key</span></span><br><span class="line">tls-auth ta.key 1　　 改为：<span class="comment">#tls-auth ta.key 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在最后面添加以下内容：</span></span><br><span class="line">&lt;ca&gt;</span><br><span class="line"><span class="comment"># ca.crt 文件内容</span></span><br><span class="line">&lt;/ca&gt;</span><br><span class="line">&lt;cert&gt;</span><br><span class="line"><span class="comment"># client.crt 文件内容</span></span><br><span class="line">&lt;/cert&gt;</span><br><span class="line">&lt;key&gt;</span><br><span class="line"><span class="comment"># client.key 文件内容</span></span><br><span class="line">&lt;/key&gt;</span><br><span class="line">key-direction 1</span><br><span class="line">&lt;tls-auth&gt;</span><br><span class="line"><span class="comment"># ta.key 文件内容</span></span><br><span class="line">&lt;/tls-auth&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制各文件里的内容到相应的位置即可！保存退出！！</span></span><br></pre></td></tr></table></figure>

<h2 id="0x08-故障修复"><a href="#0x08-故障修复" class="headerlink" title="0x08. 故障修复"></a>0x08. 故障修复</h2><h3 id="TLS密钥协商在60秒内失败"><a href="#TLS密钥协商在60秒内失败" class="headerlink" title="TLS密钥协商在60秒内失败"></a>TLS密钥协商在60秒内失败</h3><blockquote>
<p>TLS错误：TLS密钥协商在60秒内失败（检查您的网络连接）</p>
</blockquote>
<p>设置OpenVPN时最常见的问题之一是，连接两端的两个OpenVPN守护程序都无法彼此建立TCP或UDP连接。</p>
<p>这几乎是由于以下原因造成的：</p>
<ul>
<li><p>服务器网络上的外围防火墙正在过滤传入的OpenVPN数据包（默认情况下，OpenVPN使用UDP或TCP端口号1194）。</p>
</li>
<li><p>在OpenVPN服务器计算机上运行的软件防火墙本身正在过滤端口1194上的传入连接。请注意，除非另有配置，否则许多操作系统默认情况下会阻止传入连接。</p>
</li>
<li><p>服务器网络上的NAT网关没有TCP &#x2F; UDP 1194到OpenVPN服务器计算机内部地址的端口转发规则。<br>OpenVPN客户端配置在其配置文件中没有正确的服务器地址。客户端配置文件中的remote指令必须指向服务器本身或服务器网络网关的公共IP地址。</p>
</li>
<li><p>另一个可能的原因是Windows防火墙阻止了对openvpn.exe二进制文件的访问。您可能需要将其列入白名单（添加到“例外”列表中），OpenVPN才能正常工作。</p>
</li>
</ul>
<p>在您的情况下，任何这些也很可能导致相同的问题。因此，只需逐一浏览。</p>
<h3 id="Failed-to-start-OpenVPN-Robust"><a href="#Failed-to-start-OpenVPN-Robust" class="headerlink" title="Failed to start OpenVPN Robust"></a>Failed to start OpenVPN Robust</h3><p>Failed to start OpenVPN Robust And Highly Flexible Tunneling Application</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这次出现这个故障的原因是SELinux，因为从Windows系统上传配置文件到Linux系统，造成selinux的权限设置有问题</span></span><br></pre></td></tr></table></figure>

<h2 id="0x09-参考文章"><a href="#0x09-参考文章" class="headerlink" title="0x09. 参考文章"></a>0x09. 参考文章</h2><ul>
<li><a href="https://cloud.tencent.com/developer/article/1871073">Centos7安装与配置OpenVPN服务器 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></li>
<li><a href="https://chanjarster.github.io/post/network/ip-forwarding-masq-nat/">IP Forwarding, Masquerading 和 NAT</a></li>
</ul>
]]></content>
      <categories>
        <category>自建服务</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>openvpn</tag>
        <tag>security</tag>
        <tag>self-hosted</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust “类型”</title>
    <url>/2024/12/14/Rust-Types/</url>
    <content><![CDATA[<h1 id="0x01-标量类型"><a href="#0x01-标量类型" class="headerlink" title="0x01. 标量类型"></a>0x01. 标量类型</h1><p>标量类型表示单个值。Rust 有四种主要标量类型：整数、浮点数、布尔值和字符。</p>
<span id="more"></span>

<h2 id="1-1-整数类型"><a href="#1-1-整数类型" class="headerlink" title="1.1 整数类型"></a>1.1 整数类型</h2><p>Rust 中的整数类型：</p>
<table>
<thead>
<tr>
<th align="center">Length</th>
<th align="center">Signed</th>
<th align="center">Unsigned</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8-bit</td>
<td align="center"><code>i8</code></td>
<td align="center"><code>u8</code></td>
</tr>
<tr>
<td align="center">16-bit</td>
<td align="center"><code>i16</code></td>
<td align="center"><code>u16</code></td>
</tr>
<tr>
<td align="center">32-bit</td>
<td align="center"><code>i32</code></td>
<td align="center"><code>u32</code></td>
</tr>
<tr>
<td align="center">64-bit</td>
<td align="center"><code>i64</code></td>
<td align="center"><code>u64</code></td>
</tr>
<tr>
<td align="center">128-bit</td>
<td align="center"><code>i128</code></td>
<td align="center"><code>u128</code></td>
</tr>
<tr>
<td align="center">arch</td>
<td align="center"><code>isize</code></td>
<td align="center"><code>usize</code></td>
</tr>
</tbody></table>
<p>Rust 中的整数字面量：</p>
<table>
<thead>
<tr>
<th align="center">Numberliterals</th>
<th align="center">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Decimal</td>
<td align="center"><code>98_222</code></td>
</tr>
<tr>
<td align="center">Hex</td>
<td align="center"><code>0xff</code></td>
</tr>
<tr>
<td align="center">Octal</td>
<td align="center"><code>0o77</code></td>
</tr>
<tr>
<td align="center">Binary</td>
<td align="center"><code>0b1111_0000</code></td>
</tr>
<tr>
<td align="center">Byte (<code>u8</code> only)</td>
<td align="center"><code>b&#39;A&#39;</code></td>
</tr>
</tbody></table>
<h2 id="1-2-浮点类型"><a href="#1-2-浮点类型" class="headerlink" title="1.2 浮点类型"></a>1.2 浮点类型</h2><ul>
<li>Rust 还具有两种浮点数基本类型，即带有小数点的数字。</li>
<li>Rust 的浮点类型是 f32 和 f64，大小分别为 32 位和 64 位。</li>
<li>默认类型为 f64，因为在现代 CPU 上，它的速度与 f32 大致相同，但精度更高。</li>
<li>所有浮点类型都是有符号的。</li>
</ul>
<h2 id="1-3-布尔类型"><a href="#1-3-布尔类型" class="headerlink" title="1.3 布尔类型"></a>1.3 布尔类型</h2><ul>
<li>Rust 中的布尔类型有两个可能的值：true 和 false。</li>
<li>布尔值的大小为一个字节。</li>
</ul>
<p>Rust 中的布尔类型使用 bool 指定。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-字符类型"><a href="#1-4-字符类型" class="headerlink" title="1.4 字符类型"></a>1.4 字符类型</h2><p>Rust 的 char 类型是该语言最原始的字母类型。以下是声明 char 值的一些示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = &#x27;😻&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，我们<strong>用单引号指定 char 文字</strong>，而不是使用双引号的字符串文字。Rust 的 <strong>char 类型大小为四个字节，表示 Unicode 标量值</strong>，这意味着它可以表示的不仅仅是 ASCII。重音字母；中文、日文和韩文字符；表情符号；以及零宽度空格都是 Rust 中的有效 char 值。</p>
<p>Unicode 标量值的范围从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF （含）。但是，“字符”在 Unicode 中并不是一个真正的概念，因此你对“字符”的人类直觉可能与 Rust 中的 char 不匹配。我们将在第 8 章“<a href="https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">使用字符串存储 UTF-8 编码文本</a> ”中详细讨论这个主题。</p>
<h1 id="0x02-字符串类型"><a href="#0x02-字符串类型" class="headerlink" title="0x02. 字符串类型"></a>0x02. 字符串类型</h1><p>看一下图 4-1，了解 String 内部发生了什么。String 由三部分组成，如左侧所示：指向保存字符串内容的内存的指针、长度和容量。这组数据存储在堆栈上。右侧是保存内容的堆上的内存。</p>
<h2 id="2-1-创建字符串"><a href="#2-1-创建字符串" class="headerlink" title="2.1 创建字符串"></a>2.1 创建字符串</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="0x03-复合类型"><a href="#0x03-复合类型" class="headerlink" title="0x03. 复合类型"></a>0x03. 复合类型</h1><h2 id="3-2-数组"><a href="#3-2-数组" class="headerlink" title="3.2 数组"></a>3.2 数组</h2><p>另一种拥有多个值集合的方法是使用数组。与元组不同，数组的每个元素都<strong>必须具有相同的类型</strong>。与其他一些语言中的数组不同，Rust 中的数组<strong>具有固定长度</strong>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以使用方括号来编写数组的类型，其中包含每个元素的类型、分号，然后是数组中元素的数量，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>您还可以通过指定初始值，后跟分号，然后在方括号中指定数组的长度，来初始化一个数组，使其每个元素包含相同的值，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 这与 let a = [3, 3, 3, 3, 3]; 的写法相同，但更简洁。</span></span><br></pre></td></tr></table></figure>

<p>数组是一块已知且固定大小的内存，可在堆栈上分配。您可以使用索引来访问数组的元素，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-元组"><a href="#3-1-元组" class="headerlink" title="3.1 元组"></a>3.1 元组</h2><p>元组是一种将多个具有各种类型的值组合成一种复合类型的通用方法。元组的长度是固定的：一旦声明，它们的大小就不能增加或缩小。</p>
<p>我们通过在括号内写入逗号分隔的值列表来创建元组。元组中的每个位置都有一个类型，并且元组中不同值的类型不必相同。我们在此示例中添加了可选的类型注释：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 tup 绑定到整个元组，因为元组被视为单个复合元素。要从元组中获取单个值，我们可以使用模式匹配来解构元组值，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以使用句点 (<code>.</code>) 后跟要访问的值的索引来直接访问元组元素。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six_point_four</span> = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有任何值的元组有一个特殊名称，即 <code>unit</code>。此值及其对应的类型都写为 <code>()</code>，表示空值或空返回类型。如果表达式不返回任何其他值，则隐式返回 unit 值。</p>
<h2 id="3-3-结构体"><a href="#3-3-结构体" class="headerlink" title="3.3 结构体"></a>3.3 结构体</h2><p>结构体类似于“元组类型”部分中讨论的元组，因为两者都包含多个相关值。与元组一样，结构体的各个部分可以是不同的类型。与元组不同，在结构体中，您将命名每个数据部分，以便清楚地了解值的含义。添加这些名称意味着结构体比元组更灵活：您不必依赖数据的顺序来指定或访问实例的值。</p>
<p>要定义结构体，我们输入关键字 struct 并命名整个结构体。结构体的名称应该描述将数据组合在一起的意义。然后，在花括号内，我们定义数据的名称和类型，我们称之为字段。例如，清单 5-1 显示了一个存储有关用户帐户信息的结构体。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要在定义结构体后使用它，我们需要通过为每个字段指定具体值来创建该结构的实例。我们通过声明结构体的名称来创建实例，然后添加包含键：值对的大括号，其中键是字段的名称，值是我们想要存储在这些字段中的数据。我们不必按照在结构体中声明字段的顺序指定字段。换句话说，结构体定义就像类型的通用模板，实例用特定数据填充该模板以创建类型的值。例如，我们可以声明一个特定的用户，如示例 5-2 所示。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要从结构体中获取特定值，我们使用点符号。例如，要访问此用户的电子邮件地址，我们使用 user1.email。如果实例是可变的，我们可以使用点符号并赋值到特定字段来更改值。清单 5-3 显示了如何更改可变 User 实例的 email 字段中的值。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清单 5-4 显示了 build_user 函数，该函数返回具有给定电子邮件和用户名的 User 实例。active 字段的值为 true，sign_in_count 的值为 1。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: username,</span><br><span class="line">        email: email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将函数参数命名为与结构字段相同的名称是有意义的，但必须重复电子邮件和用户名字段名称和变量有点乏味。如果结构有更多字段，重复每个名称会变得更加烦人。幸运的是，有一个方便的简写！</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username,</span><br><span class="line">        email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们创建了 User 结构体的一个新实例，该结构体有一个名为 email 的字段。我们想将 email 字段的值设置为 build_user 函数的 email 参数中的值。由于 email 字段和 email 参数同名，因此我们只需要写 email 而不是 email: email。</p>
<h3 id="3-3-1-结构体更新语法"><a href="#3-3-1-结构体更新语法" class="headerlink" title="3.3.1 结构体更新语法"></a>3.3.1 结构体更新语法</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        active: user1.active,</span><br><span class="line">        username: user1.username,</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: user1.sign_in_count,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清单 5-7 中的代码还在 user2 中创建了一个实例，该实例的 email 值与 user1 不同，但 username、active 和 sign_in_count 字段的值与 user1 相同。..user1 必须放在最后，以指定任何剩余字段应从 user1 中的相应字段中获取其值，但我们可以选择以任意顺序为任意数量的字段指定值，而不管结构定义中字段的顺序如何。</p>
<h3 id="3-3-2-元组结构体"><a href="#3-3-2-元组结构体" class="headerlink" title="3.3.2  元组结构体"></a>3.3.2  元组结构体</h3><p>Rust 还支持类似于元组的结构，称为元组结构。元组结构具有结构名称提供的附加含义，但没有与其字段关联的名称；相反，它们只有字段的类型。当你想给整个元组命名并使元组与其他元组的类型不同，并且像在常规结构中一样命名每个字段会很冗长或冗余时，元组结构很有用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-单元结构体"><a href="#3-3-3-单元结构体" class="headerlink" title="3.3.3 单元结构体"></a>3.3.3 单元结构体</h3><p>您还可以定义没有任何字段的结构体！这些被称为类单元结构，因为它们的行为类似于 <code>()</code>，后者是我们在“元组类型”部分中提到的单元类型。当您需要在某种类型上实现特征但没有任何要存储在类型本身中的数据时，类单元结构会很有用。以下是声明和实例化名为 <code>AlwaysEqual</code> 的单元结构体的示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-枚举"><a href="#3-4-枚举" class="headerlink" title="3.4 枚举"></a>3.4 枚举</h2><p>我们可以通过定义 IpAddrKind 枚举并列出 IP 地址可能的类型 V4 和 V6，在代码中表达这一概念。这些是枚举的变体：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以像这样创建 IpAddrKind 的两个变体的实例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br></pre></td></tr></table></figure>

<p>请注意，枚举的变体在其标识符下命名，我们使用双冒号将两者分开。这很有用，因为现在 IpAddrKind::V4 和 IpAddrKind::V6 这两个值都属于同一类型：IpAddrKind。然后，例如，我们可以定义一个接受任何 IpAddrKind 的函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">route</span>(ip_kind: IpAddrKind) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以用以下任一方式调用该函数：</span></span><br><span class="line"><span class="title function_ invoke__">route</span>(IpAddrKind::V4);</span><br><span class="line"><span class="title function_ invoke__">route</span>(IpAddrKind::V6);</span><br></pre></td></tr></table></figure>

<p>使用枚举而不是结构还有另一个优势：每个变体可以具有不同类型和数量的关联数据。版本 4 IP 地址将始终具有四个数字组件，其值介于 0 到 255 之间。如果我们想将 V4 地址存储为四个 u8 值，但仍将 V6 地址表示为一个字符串值，则无法使用结构。枚举可以轻松处理这种情况：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>让我们看一下示例 6-2 中的另一个枚举示例：这个示例的变体中嵌入了多种类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此枚举有四种不同类型的变体：</p>
<ul>
<li>Quit 根本没有与之关联的数据。</li>
<li>Move 有命名字段，就像结构一样。</li>
<li>Write 包含单个字符串。</li>
<li>ChangeColor 包含三个 i32 值。</li>
</ul>
<h3 id="3-4-1-Option-枚举"><a href="#3-4-1-Option-枚举" class="headerlink" title="3.4.1 Option 枚举"></a>3.4.1 Option 枚举</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-Result-枚举"><a href="#3-4-2-Result-枚举" class="headerlink" title="3.4.2 Result 枚举"></a>3.4.2 Result 枚举</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x04-集合类型"><a href="#0x04-集合类型" class="headerlink" title="0x04. 集合类型"></a>0x04. 集合类型</h1><h2 id="4-1-向量-Vec"><a href="#4-1-向量-Vec" class="headerlink" title="4.1 向量 Vec&lt;T&gt;"></a>4.1 向量 <code>Vec&lt;T&gt;</code></h2><p>我们将要介绍的第一个集合类型是 <code>Vec&lt;T&gt;</code>，也称为向量。向量允许您在单个数据结构中存储多个值，该数据结构将所有值并排放置在内存中。向量<strong>只能存储相同类型</strong>的值。当您有项目列表时，它们很有用，例如文件中的文本行或购物车中项目的价格。</p>
<h3 id="4-1-1-创建新向量"><a href="#4-1-1-创建新向量" class="headerlink" title="4.1.1 创建新向量"></a>4.1.1 创建新向量</h3><p>为了创建一个新的空向量，我们调用 Vec::new 函数，如示例 8-1 所示。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<p>更常见的情况是，你会创建一个带有初始值的 Vec<T>，Rust 会推断出你想要存储的值的类型，所以你很少需要做这种类型注释。Rust 方便地提供了 vec! 宏，它将创建一个新的向量来保存你给它的值。示例 8-2 创建了一个新的 Vec<i32>，它保存了值 1、2 和 3。整数类型是 i32，因为这是默认的整数类型，正如我们在第 3 章的“数据类型”部分讨论的那样。</i32></T></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-更新向量"><a href="#4-1-2-更新向量" class="headerlink" title="4.1.2 更新向量"></a>4.1.2 更新向量</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">7</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-读取向量元素"><a href="#4-1-3-读取向量元素" class="headerlink" title="4.1.3 读取向量元素"></a>4.1.3 读取向量元素</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; = v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">match</span> third &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-1-4-迭代向量中的值"><a href="#4-1-4-迭代向量中的值" class="headerlink" title="4.1.4 迭代向量中的值"></a>4.1.4 迭代向量中的值</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;i&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以迭代可变向量中每个元素的可变引用，以便更改所有元素。示例 8-8 中的 for 循环将为每个元素添加 50。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要更改可变引用所指的值，我们必须先使用 <code>*</code> 解引用运算符来获取 i 中的值，然后才能使用 +&#x3D; 运算符。我们将在第 15 章的“使用解引用运算符跟踪指针指向值”部分中进一步讨论解引用运算符。</p>
<h3 id="4-1-5-使用枚举存储多种类型"><a href="#4-1-5-使用枚举存储多种类型" class="headerlink" title="4.1.5 使用枚举存储多种类型"></a>4.1.5 使用枚举存储多种类型</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="4-2-哈希映射-HashMap"><a href="#4-2-哈希映射-HashMap" class="headerlink" title="4.2 哈希映射 HashMap&lt;K, V&gt;"></a>4.2 哈希映射 <code>HashMap&lt;K, V&gt;</code></h2><h3 id="4-2-1-创建新的-HashMap"><a href="#4-2-1-创建新的-HashMap" class="headerlink" title="4.2.1 创建新的 HashMap&lt;K, V&gt;"></a>4.2.1 创建新的 <code>HashMap&lt;K, V&gt;</code></h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-访问哈希映射中的值"><a href="#4-2-2-访问哈希映射中的值" class="headerlink" title="4.2.2 访问哈希映射中的值"></a>4.2.2 访问哈希映射中的值</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以使用与向量类似的方式，使用 for 循环遍历哈希图中的每个键值对：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;key&#125;: &#123;value&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>基线核查与加固 - MySQL</title>
    <url>/2023/10/29/harden-mysql/</url>
    <content><![CDATA[<blockquote>
<p>基于 <code>MySQL8.0.12</code> 进行操作，环境：<code>phpstudy_pro</code> &amp; <code>Windows11</code></p>
<ol>
<li>网络安全等级保护基本要求 - <code>第三级安全要求</code> - <code>安全计算环境</code></li>
<li>核查</li>
<li>加固</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="8-1-4-安全计算环境"><a href="#8-1-4-安全计算环境" class="headerlink" title="8.1.4 安全计算环境"></a>8.1.4 安全计算环境</h2><h3 id="8-1-4-1-身份鉴别"><a href="#8-1-4-1-身份鉴别" class="headerlink" title="8.1.4.1 身份鉴别"></a>8.1.4.1 身份鉴别</h3><p>本项要求包括：</p>
<p>a) 应对登录的用户进行身份标识和鉴别，身份标识具有唯一性，身份鉴别信息具有复杂度要求并定期更换；</p>
<ul>
<li>核查密码复杂度</li>
<li>核查密码生命周期</li>
</ul>
<p>b) 应具有登录失败处理功能，应配置并启用结束会话、限制非法登录次数和当登录连接超时自动退出等相关措施；</p>
<ul>
<li>核查是否限制非法登录次数</li>
<li>核查登录连接超时配置</li>
</ul>
<p>c) 当进行远程管理时，应采取必要措施防止鉴别信息在网络传输过程中被窃听；</p>
<ul>
<li>核查是否开启远程加密通信</li>
</ul>
<p>d) 应采用口令、密码技术、生物技术等两种或两种以上组合的鉴别技术对用户进行身份鉴别，且其中一种鉴别技术至少应使用密码技术来实现。</p>
<ul>
<li>不适用</li>
</ul>
<h4 id="核查密码复杂度"><a href="#核查密码复杂度" class="headerlink" title="核查密码复杂度"></a>核查密码复杂度</h4><p>MySQL 系统自带有 validate_password 插件，此插件可以验证密码强度，未达到规定强度的密码则不允许被设置。MySQL 5.7 及 8.0 版本默认情况下貌似都不启用该插件，这也使得我们可以随意设置密码，比如设置为 123、123456等。如果我们想从根源上规范密码强度，可以启用该插件，下面一起来看下如何通过此插件来设置密码复杂度策略。</p>
<h5 id="核查方式"><a href="#核查方式" class="headerlink" title="核查方式"></a>核查方式</h5><p>安装前检查 为空则说明未安装此插件：<code>show variables like &#39;validate%&#39;; </code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;validate%&#x27;; </span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212213316407.png" alt="image-20221212213316407"></p>
<h5 id="加固方式"><a href="#加固方式" class="headerlink" title="加固方式"></a>加固方式</h5><h6 id="1）安装-validate-password-插件"><a href="#1）安装-validate-password-插件" class="headerlink" title="1）安装 validate_password 插件"></a>1）安装 validate_password 插件</h6><p><code>INSTALL PLUGIN validate_password SONAME &#39;validate_password.so&#39;;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通过 INSTALL PLUGIN 命令可安装此插件</span><br><span class="line"># 每个平台的文件名后缀都不同 对于 Unix 和类 Unix 系统，为.so，对于 Windows 为.dll</span><br><span class="line">mysql&gt; INSTALL PLUGIN validate_password SONAME &#x27;validate_password.so&#x27;;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.28 sec)</span><br><span class="line"></span><br><span class="line"># 查看 validate_password 相关参数</span><br><span class="line">mysql&gt; show variables like &#x27;validate%&#x27;;</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| Variable_name                        | Value  |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| validate_password_check_user_name    | ON     |</span><br><span class="line">| validate_password_dictionary_file    |        |</span><br><span class="line">| validate_password_length             | 8      |</span><br><span class="line">| validate_password_mixed_case_count   | 1      |</span><br><span class="line">| validate_password_number_count       | 1      |</span><br><span class="line">| validate_password_policy             | MEDIUM |</span><br><span class="line">| validate_password_special_char_count | 1      |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212213649720.png" alt="image-20221212213649720"></p>
<h6 id="2）密码强度相关参数解释"><a href="#2）密码强度相关参数解释" class="headerlink" title="2）密码强度相关参数解释"></a>2）密码强度相关参数解释</h6><p>安装 validate_password 插件后，多了一些密码强度相关参数，这些参数从字面意思上也很容易看懂，下面简单解释下几个重点参数。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> validate<span class="emphasis">_password_</span>policy</span><br><span class="line"><span class="bullet">	-</span> 代表的密码策略，默认是MEDIUM 可配置的值有以下：</span><br><span class="line"><span class="code">        0 or LOW 仅需需符合密码长度（由参数validate_password_length指定）</span></span><br><span class="line"><span class="code">        1 or MEDIUM 满足LOW策略，同时还需满足至少有1个数字，小写字母，大写字母和特殊字符</span></span><br><span class="line"><span class="code">        2 or STRONG 满足MEDIUM策略，同时密码不能存在字典文件（dictionary file）中</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">2.</span> validate<span class="emphasis">_password_</span>dictionary<span class="emphasis">_file</span></span><br><span class="line"><span class="emphasis">	- 用于配置密码的字典文件，当validate_</span>password<span class="emphasis">_policy设置为STRONG时可以配置密码字典文件，字典文件中存在的密码不得使用。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">3. validate_</span>password<span class="emphasis">_length</span></span><br><span class="line"><span class="emphasis">	- 用来设置密码的最小长度，默认值是8</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">4. validate_</span>password<span class="emphasis">_mixed_</span>case<span class="emphasis">_count</span></span><br><span class="line"><span class="emphasis">	- 当validate_</span>password<span class="emphasis">_policy设置为MEDIUM或者STRONG时，密码中至少同时拥有的小写和大写字母的数量</span></span><br><span class="line"><span class="emphasis">	- 默认是1最小是0；默认是至少拥有一个小写和一个大写字母。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">5. validate_</span>password<span class="emphasis">_number_</span>count</span><br><span class="line"><span class="bullet">	-</span> 当validate<span class="emphasis">_password_</span>policy设置为MEDIUM或者STRONG时，密码中至少拥有的数字的个数，默认1最小是0</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> validate<span class="emphasis">_password_</span>special<span class="emphasis">_char_</span>count</span><br><span class="line"><span class="bullet">	-</span> 当validate<span class="emphasis">_password_</span>policy设置为MEDIUM或者STRONG时，密码中至少拥有的特殊字符的个数，默认1最小是0</span><br></pre></td></tr></table></figure>

<h6 id="3）密码复杂度策略具体设置"><a href="#3）密码复杂度策略具体设置" class="headerlink" title="3）密码复杂度策略具体设置"></a>3）密码复杂度策略具体设置</h6><p><code>set global validate_password_length = 16;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置密码长度至少10位</span><br><span class="line">mysql&gt; set global validate_password_length = 16;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;validate%&#x27;;                                                                                   </span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| Variable_name                        | Value  |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| validate_password_check_user_name    | ON     |</span><br><span class="line">| validate_password_dictionary_file    |        |</span><br><span class="line">| validate_password_length             | 16     |</span><br><span class="line">| validate_password_mixed_case_count   | 1      |</span><br><span class="line">| validate_password_number_count       | 1      |</span><br><span class="line">| validate_password_policy             | MEDIUM |</span><br><span class="line">| validate_password_special_char_count | 1      |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>!!! note “若想永久生效，建议将以下参数写入配置文件”</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">plugin-load = validate_password.dll</span><br><span class="line">validate_password_length = 16</span><br><span class="line">validate_password_policy = 1</span><br><span class="line">validate-password = FORCE_PLUS_PERMANENT</span><br></pre></td></tr></table></figure>
</code></pre>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212220000175.png" alt="image-20221212220000175"></p>
<h4 id="核查密码生命周期"><a href="#核查密码生命周期" class="headerlink" title="核查密码生命周期"></a>核查密码生命周期</h4><h5 id="核查方式-1"><a href="#核查方式-1" class="headerlink" title="核查方式"></a>核查方式</h5><p>查看密码有效期：<code>SHOW VARIABLES LIKE &#39;default_password_lifetime&#39;; </code></p>
<blockquote>
<p><code>default_password_lifetime</code> 设置为 <code>0</code> ，即表示密码永不过期。</p>
</blockquote>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212211606097.png" alt="image-20221212211606097"></p>
<h5 id="加固方式-1"><a href="#加固方式-1" class="headerlink" title="加固方式"></a>加固方式</h5><ul>
<li><p>一次性设置全局过期策略：<code>SET GLOBAL default_password_lifetime = 90;</code></p>
</li>
<li><p>或者直接写入配置文件并重启以永久生效</p>
  <figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入配置文件使得重启生效</span></span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">default_password_lifetime</span> = <span class="number">90</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>设置全局过期策略后，需要把配置写入配置文件 <code>mysql.cn</code>中并重启才能永久生效，否则 <code>MySQL</code> 重启后恢复默认值。</p>
</blockquote>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212211840616.png" alt="image-20221212211840616"></p>
<h4 id="核查是否限制非法登录次数"><a href="#核查是否限制非法登录次数" class="headerlink" title="核查是否限制非法登录次数"></a>核查是否限制非法登录次数</h4><p>MySQL&gt;&#x3D; 5.7.17 以后提供了 Connection-Control 插件，用来控制客户端在登录操作连续失败一定次数后的响应的延迟。</p>
<h5 id="核查方式-2"><a href="#核查方式-2" class="headerlink" title="核查方式"></a>核查方式</h5><ul>
<li><code>show variables like &#39;%connection_control%&#39;;</code><ul>
<li>为空，则未启用插件，需要安装再进行加固。</li>
</ul>
</li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212220652885.png" alt="image-20221212220652885"></p>
<h5 id="加固方式-2"><a href="#加固方式-2" class="headerlink" title="加固方式"></a>加固方式</h5><h6 id="1）安装-Connection-Control-插件"><a href="#1）安装-Connection-Control-插件" class="headerlink" title="1）安装 Connection-Control 插件"></a>1）安装 Connection-Control 插件</h6><ul>
<li>CONNECTION_CONTROL：用来控制登录失败的次数及延迟响应时间。</li>
<li>CONNECTION_CONTROL_FAILED_LOGIN_ATTEMPTS：该表将登录失败的操作记录至IS库中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 每个平台的文件名后缀都不同 对于 Unix 和类 Unix 系统，为.so，对于 Windows 为.dll</span><br><span class="line">install plugin CONNECTION_CONTROL soname &#x27;connection_control.so&#x27;;</span><br><span class="line">install plugin CONNECTION_CONTROL_FAILED_LOGIN_ATTEMPTS soname &#x27;connection_control.so&#x27;;</span><br><span class="line">	# 开启的选项</span><br><span class="line">	# connection_control_failed_connections_threshold	3</span><br><span class="line">	# connection_control_max_connection_delay	2147483647</span><br><span class="line">	# connection_control_min_connection_delay	1000</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h6 id="2）参数解释"><a href="#2）参数解释" class="headerlink" title="2）参数解释"></a>2）参数解释</h6><ul>
<li><p>connection_control_failed_connections_threshold</p>
<ul>
<li>失败尝试的次数，默认为3，表示当连接失败3次后启用连接控制，0表示不开启。</li>
</ul>
</li>
<li><p>connection_control_max_connection_delay</p>
<ul>
<li>响应延迟的最大时间，默认约25天</li>
</ul>
</li>
<li><p>connection_control_min_connection_delay</p>
<ul>
<li>响应延迟的最小时间，默认1000微秒，1秒</li>
</ul>
</li>
</ul>
<h6 id="3）具体配置"><a href="#3）具体配置" class="headerlink" title="3）具体配置"></a>3）具体配置</h6><p>方式一：修改配置文件 <code>my.cnf</code> or <code>my.ini</code>（永久生效）</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/my.cnf</span></span><br><span class="line"><span class="comment"># 添加下面两项</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.登陆失败次数限制</span></span><br><span class="line"><span class="attr">connection-control-failed-connections-threshold</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.限制重试时间，此处为毫秒，注意按需求换算</span></span><br><span class="line"><span class="attr">connection-control-min-connection-delay</span>=<span class="number">900000</span> </span><br></pre></td></tr></table></figure>

<p>方式二：设置全局变量（重启失效）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 登陆失败次数限制</span><br><span class="line">SET GLOBAL connection_control_failed_connections_threshold = 5;</span><br><span class="line"></span><br><span class="line"># 限制重试时间，此处为毫秒，注意按需求换算</span><br><span class="line">SET GLOBAL connection_control_min_connection_delay = 900000;</span><br><span class="line"></span><br><span class="line"># 配置完成，再次查看参数：</span><br><span class="line">show variables like &#x27;%connection_control%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212222219404.png" alt="image-20221212222219404"></p>
<h4 id="核查超时功能"><a href="#核查超时功能" class="headerlink" title="核查超时功能"></a>核查超时功能</h4><blockquote>
<p>从官方文档上来看 wait_timeout 和 interactive_timeout 都是指不活跃的连接超时时间，连接线程启动的时候wait_timeout会根据是交互模式还是非交互模式被设置为这两个值中的一个。</p>
<p>如果我们运行mysql -uroot -p命令登陆到mysql，wait_timeout就会被设置为interactive_timeout的值。<br>如果我们在wait_timeout时间内没有进行任何操作，那么再次操作的时候就会提示超时，这时 mysql client会重新连接。</p>
</blockquote>
<p>MySQL连接超时退出主要看三个参数：</p>
<ul>
<li><p>interactive_timeout</p>
<ul>
<li>服务器关闭交互式连接前等待活动的秒数。</li>
</ul>
</li>
<li><p>wait_timeout</p>
<ul>
<li>服务器关闭非交互连接之前等待活动的秒数。</li>
</ul>
</li>
<li><p>两者生效取决于</p>
<ul>
<li>客户端是交互或者非交互的连接。</li>
<li>在交互模式下，interactive_timeout才生效；非交互模式下，wait_timeout生效。</li>
</ul>
</li>
<li><p>connect_timeout &#x3D;10</p>
<ul>
<li>指的是连接过程中握手的超时时间(s)</li>
</ul>
</li>
</ul>
<h5 id="核查方式-3"><a href="#核查方式-3" class="headerlink" title="核查方式"></a>核查方式</h5><ul>
<li><code>show global variables like &#39;%timeout%&#39;;</code></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212223356808.png" alt="image-20221212223356808"></p>
<h5 id="加固方式-3"><a href="#加固方式-3" class="headerlink" title="加固方式"></a>加固方式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置全局变量 `connect_timeout` 为 `10s`</span><br><span class="line">msyql&gt; set global connect_timeout=10;</span><br><span class="line"></span><br><span class="line"># 设置 MySQL Server 超时时间（以秒为单位）</span><br><span class="line"># 默认是28800，即8小时。</span><br><span class="line">msyql&gt; set global wait_timeout=28800;</span><br><span class="line">msyql&gt; set global interactive_timeout=28800;</span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212225225553.png" alt="image-20221212225225553"></p>
<h4 id="核查是否开启远程加密通信"><a href="#核查是否开启远程加密通信" class="headerlink" title="核查是否开启远程加密通信"></a>核查是否开启远程加密通信</h4><h5 id="核查方式-4"><a href="#核查方式-4" class="headerlink" title="核查方式"></a>核查方式</h5><ul>
<li><code>show variables like &#39;have_openssl&#39;;</code></li>
<li><code>SHOW VARIABLES LIKE &#39;%ssl%&#39;;</code></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212203451814.png" alt="image-20221212203451814"></p>
<blockquote>
<p>MySQL8.0.12默认开启加密通信</p>
<p>禁用加密通信：在配置文件 <code>my.cnf</code> 中的 <code>[mysqld]</code> 下加入<code>skip_ssl</code>，重启MySQL。</p>
</blockquote>
<h5 id="加固方式-4"><a href="#加固方式-4" class="headerlink" title="加固方式"></a>加固方式</h5><p>加固通信传输要求项：启用 <code>ssl</code> 加密通信，<em><strong>注释</strong></em> 配置文件 <code>my.cnf</code> 中的 <code>[mysqld]</code> 下的<code>skip_ssl</code>，并在下面追加 <code>ssl</code>，重启MySQL。</p>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212204608383.png" alt="image-20221212204608383"></p>
<h3 id="8-1-4-2-访问控制"><a href="#8-1-4-2-访问控制" class="headerlink" title="8.1.4.2 访问控制"></a>8.1.4.2 访问控制</h3><p>本项要求包括：</p>
<p>a) 应对登录的用户分配账户和权限；</p>
<ul>
<li>核查是否对登录的用户分配账户和权限</li>
</ul>
<p>b) 应重命名或删除默认账户，修改默认账户的默认口令；</p>
<ul>
<li>核查是否重命名账号</li>
<li>核查是否修改默认口令</li>
</ul>
<p>c) 应及时删除或停用多余的、过期的账户，避免共享账户的存在；</p>
<ul>
<li>核查是否存在多余的、过期的账号</li>
</ul>
<p>d) 应授予管理用户所需的最小权限，实现管理用户的权限分离；</p>
<p>e) 应由授权主体配置访问控制策略，访问控制策略规定主体对客体的访问规则；</p>
<p>f) 访问控制的粒度应达到主体为用户级或进程级，客体为文件、数据库表级；</p>
<p>g) 应对重要主体和客体设置安全标记，并控制主体对有安全标记信息资源的访问。</p>
<h4 id="核查是否对登录的用户分配账户和权限"><a href="#核查是否对登录的用户分配账户和权限" class="headerlink" title="核查是否对登录的用户分配账户和权限"></a>核查是否对登录的用户分配账户和权限</h4><h5 id="核查方式-5"><a href="#核查方式-5" class="headerlink" title="核查方式"></a>核查方式</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MySQL 中所有使用者的权限是记录在 `mysql` 这个数据库的 `user` 资料表中:</span></span><br><span class="line">SELECT * FROM mysql.user;</span><br><span class="line"><span class="comment"># 你可以看到所有的使用者权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有关db的数据是记录在Db(大小写要注意)这个数据表中</span></span><br><span class="line">SELECT * FROM mysql.Db;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者你可以用条件查询找出你要的答案</span></span><br><span class="line">SELECT * FROM mysql.Db WHERE Db=<span class="string">&#x27;$&#123;dbname&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213000354563.png" alt="image-20221213000354563"></p>
<h5 id="加固方式-5"><a href="#加固方式-5" class="headerlink" title="加固方式"></a>加固方式</h5><ul>
<li><p>禁止root账号远程登录</p>
</li>
<li><p>禁止程序使用root账号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 设置允许任何IP登录</span><br><span class="line">use mysql;</span><br><span class="line">update user set host=&#x27;localhost&#x27; where user=&#x27;root&#x27; and host=&#x27;%&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213000524679.png" alt="image-20221213000524679"></p>
<h4 id="核查是否重命名账号"><a href="#核查是否重命名账号" class="headerlink" title="核查是否重命名账号"></a>核查是否重命名账号</h4><h5 id="核查方式-6"><a href="#核查方式-6" class="headerlink" title="核查方式"></a>核查方式</h5><ul>
<li><code>SELECT user, host FROM mysql.user</code></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212234533536.png" alt="image-20221212234533536"></p>
<h5 id="加固方式-6"><a href="#加固方式-6" class="headerlink" title="加固方式"></a>加固方式</h5><ul>
<li><p>修改root账号名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update user set user=&#x27;haiyi_root&#x27; where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213000732709.png" alt="image-20221213000732709"></p>
<h4 id="核查是否修改默认口令"><a href="#核查是否修改默认口令" class="headerlink" title="核查是否修改默认口令"></a>核查是否修改默认口令</h4><h5 id="核查方式-7"><a href="#核查方式-7" class="headerlink" title="核查方式"></a>核查方式</h5><ul>
<li>访谈</li>
<li>查询空口令账号<ul>
<li><code>select * from mysql.user where length(authentication_string)=0 or authentication_string is null;</code></li>
</ul>
</li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213162949400.png" alt="image-20221213162949400"></p>
<h5 id="加固方式-7"><a href="#加固方式-7" class="headerlink" title="加固方式"></a>加固方式</h5><ul>
<li>修改默认口令、空口令(谨慎操作)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; USE mysql;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; UPDATE user SET authentication_string=&quot;H!q@31UI!&quot; WHERE user=&quot;root&quot;;</span><br><span class="line">Query OK, 1 row affected (0.39 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; FLUSH privileges;  # 刷新保存</span><br><span class="line">Query OK, 0 rows affected (0.13 sec)</span><br></pre></td></tr></table></figure>



<h4 id="核查是否存在多余的、过期的账号"><a href="#核查是否存在多余的、过期的账号" class="headerlink" title="核查是否存在多余的、过期的账号"></a>核查是否存在多余的、过期的账号</h4><h5 id="核查方式-8"><a href="#核查方式-8" class="headerlink" title="核查方式"></a>核查方式</h5><ul>
<li><code>SELECT user, host FROM mysql.user</code></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212235526618.png" alt="image-20221212235526618"></p>
<h5 id="加固方式-8"><a href="#加固方式-8" class="headerlink" title="加固方式"></a>加固方式</h5><ul>
<li><p>删除多余的、过期的账号，如：test, dev等测试账号。</p>
</li>
<li><p>删除 <code>test</code>：<code>drop user &#39;test&#39;@&#39;localhost&#39;;</code></p>
</li>
<li><p>删除 <code>dev</code> ：<code>drop user &#39;dev&#39;@&#39;localhost&#39;;</code></p>
</li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221212235744110.png" alt="image-20221212235744110"></p>
<h3 id="8-1-4-3-安全审计"><a href="#8-1-4-3-安全审计" class="headerlink" title="8.1.4.3 安全审计"></a>8.1.4.3 安全审计</h3><p>本项要求包括：</p>
<p>a) 应启用安全审计功能，审计覆盖到每个用户，对重要的用户行为和重要安全事件进行审计；</p>
<ul>
<li>核查是否启用日志记录</li>
</ul>
<p>b) 审计记录应包括事件的日期和时间、用户、事件类型、事件是否成功及其他与审计相关的信息；</p>
<p>c) 应对审计记录进行保护，定期备份，避免受到未预期的删除、修改或覆盖等；</p>
<ul>
<li>核查日志保存时间</li>
<li>核查日志文件权限信息</li>
</ul>
<p>d) 应对审计进程进行保护，防止未经授权的中断。</p>
<h4 id="核查是否启用日志记录"><a href="#核查是否启用日志记录" class="headerlink" title="核查是否启用日志记录"></a>核查是否启用日志记录</h4><h5 id="核查方式-9"><a href="#核查方式-9" class="headerlink" title="核查方式"></a>核查方式</h5><ul>
<li>查询所有日志相关信息：<code>show variables like &#39;%log%&#39;;</code></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213094849716.png" alt="image-20221213094849716"></p>
<h5 id="加固方式-9"><a href="#加固方式-9" class="headerlink" title="加固方式"></a>加固方式</h5><h6 id="1-开启常规日志审计功能"><a href="#1-开启常规日志审计功能" class="headerlink" title="1) 开启常规日志审计功能"></a>1) 开启常规日志审计功能</h6><ul>
<li><code>set global general_log=on;</code></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213095710756.png" alt="image-20221213095710756"></p>
<h6 id="2-开启错误日志审计功能"><a href="#2-开启错误日志审计功能" class="headerlink" title="2) 开启错误日志审计功能"></a>2) 开启错误日志审计功能</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误日志包括数据库运行和停止过程中的一系列活动信息，有助于分析数据库运行过程中的一些异常活动</span></span><br><span class="line"><span class="comment"># 一般情况下需要开启错误日志记录功能，使用如下命令查询：</span></span><br><span class="line"></span><br><span class="line">SHOW variables LIKE <span class="string">&#x27;log_error&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保返回结果为非空，如果为空，需要在mysql数据库配置文件中增加相关配置</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; log_error	D:\phpstudy_pro\Extensions\MySQL8.0.12\data.err</span></span><br></pre></td></tr></table></figure>

<h6 id="3-确保日志存放在非系统区域"><a href="#3-确保日志存放在非系统区域" class="headerlink" title="3) 确保日志存放在非系统区域"></a>3) 确保日志存放在非系统区域</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 日志文件随着数据库的运行会不断增加，如果存放在系统区域，则会影响系统的正常运行，使用如下命令进行查询：</span></span><br><span class="line"></span><br><span class="line">SELECT @@global.log_bin_basename;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保返回结果不是如下路径：/、/var、/usr</span></span><br></pre></td></tr></table></figure>

<h6 id="4-关闭原始日志功能"><a href="#4-关闭原始日志功能" class="headerlink" title="4) 关闭原始日志功能"></a>4) 关闭原始日志功能</h6><blockquote>
<p>当 <code>log-raw</code> 记录启用时，有权访问日志文件的人可能会看到纯文本密码。</p>
<p>编辑 MySQL 配置文件 <code>/etc/my.cnf</code> ，删除 <code>log-raw</code> 参数，并重启 <code>mysql</code> 服务</p>
<blockquote>
<p>上述与下面的操作好像有点冲突，以实际情况为准。待探索……</p>
</blockquote>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原始日志选项会决定一些敏感信息是否会被明文写进日志中，例如查询日志、慢查询日志、二进制日志</span></span><br><span class="line"><span class="comment"># 确保数据库配置文件中存在如下配置项：</span></span><br><span class="line"></span><br><span class="line">log-raw = OFF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如无，配置并重启</span></span><br></pre></td></tr></table></figure>



<h4 id="核查日志保存时间"><a href="#核查日志保存时间" class="headerlink" title="核查日志保存时间"></a>核查日志保存时间</h4><blockquote>
<p>set global expire_logs_days&#x3D;365</p>
<p>&gt; 3683 - The option expire_logs_days and binlog_expire_logs_seconds cannot be used together. Please use binlog_expire_logs_seconds to set the expire time (expire_logs_days is deprecated)</p>
</blockquote>
<h5 id="核查方式-10"><a href="#核查方式-10" class="headerlink" title="核查方式"></a>核查方式</h5><ul>
<li>查看日志时间（已废弃）：<code>show variables like &#39;%logs_days%&#39;;</code></li>
<li>查看日志时间：<code>show variables like &#39;binlog_expire_logs_seconds&#39;;</code></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213100143478.png" alt="image-20221213100143478"></p>
<h5 id="加固方式-10"><a href="#加固方式-10" class="headerlink" title="加固方式"></a>加固方式</h5><ul>
<li><code>set global binlog_expire_logs_seconds=2596096;</code></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213100323167.png" alt="image-20221213100323167"></p>
<h4 id="核查日志文件权限信息"><a href="#核查日志文件权限信息" class="headerlink" title="核查日志文件权限信息"></a>核查日志文件权限信息</h4><h5 id="1-控制二进制日志文件的权限"><a href="#1-控制二进制日志文件的权限" class="headerlink" title="1) 控制二进制日志文件的权限"></a>1) 控制二进制日志文件的权限</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql的运行会产生很多日志，例如二进制日志、错误日志、慢查询日志等等，Mysql命令行下执行如下命令：</span></span><br><span class="line">show variables like <span class="string">&#x27;log_bin_basename&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端命令行执行如下命令：</span></span><br><span class="line"><span class="built_in">ls</span> &lt;log_bin_basename&gt;.*</span><br><span class="line"><span class="comment"># 对于发现的每一个文件，执行如下命令：</span></span><br><span class="line"><span class="built_in">ls</span> -l &lt;log_bin_basename.nnnnn&gt; | egrep <span class="string">&quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span> </span><br><span class="line"><span class="comment"># 根据输出确认日志文件的权限设置是否存在问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于每个日志文件，修改其权限和属组如下：</span></span><br><span class="line"><span class="built_in">chmod</span> 660 &lt;<span class="built_in">log</span> file&gt;</span><br><span class="line"><span class="built_in">chown</span> mysql:mysql &lt;<span class="built_in">log</span> file&gt; </span><br></pre></td></tr></table></figure>



<h5 id="2-控制数据目录、基准目录的访问权限"><a href="#2-控制数据目录、基准目录的访问权限" class="headerlink" title="2) 控制数据目录、基准目录的访问权限"></a>2) 控制数据目录、基准目录的访问权限</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据目录是mysql数据库存放的位置，在mysql命令行界面下执行如下命令：</span></span><br><span class="line">show variables <span class="built_in">where</span> variable_name = <span class="string">&#x27;datadir&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端命令行下执行如下命令：</span></span><br><span class="line"><span class="built_in">ls</span> -l &lt;datadir&gt;/.. | egrep <span class="string">&quot;^d[r|w|x]&#123;3&#125;------\s*.\s*mysql\s*mysql\s*\d*.*mysql&quot;</span></span><br><span class="line"><span class="comment"># 其中&lt;datadir&gt;是第一条命令的执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果存在问题，linux环境下在终端执行如下命令进行加固：</span></span><br><span class="line"><span class="built_in">chmod</span> 700 &lt;datadir&gt; <span class="comment">#仅MySQL数据库用户有读写权限</span></span><br><span class="line"><span class="built_in">chown</span> mysql:mysql &lt;datadir&gt; </span><br><span class="line"><span class="comment"># 同理控制基准目录权限 &lt;basedir&gt;，仅DBA和数据库用户可访问</span></span><br></pre></td></tr></table></figure>



<h5 id="3-控制错误日志文件的权限"><a href="#3-控制错误日志文件的权限" class="headerlink" title="3) 控制错误日志文件的权限"></a>3) 控制错误日志文件的权限</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 控制错误日志文件的权限</span></span><br><span class="line"><span class="comment"># Mysql命令行下执行如下命令：</span></span><br><span class="line">show variables like <span class="string">&#x27;log_error&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端命令行执行如下命令：</span></span><br><span class="line"><span class="built_in">ls</span> &lt;log_error&gt;.*</span><br><span class="line"><span class="comment"># 对于发现的每一个文件，执行如下命令：</span></span><br><span class="line"><span class="built_in">ls</span> -l &lt;log_error&gt; | egrep <span class="string">&quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span> </span><br><span class="line"><span class="comment"># 根据输出确认日志文件的权限设置是否存在问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于每个日志文件，修改其权限和属组如下：</span></span><br><span class="line"><span class="built_in">chmod</span> 660 &lt;<span class="built_in">log</span> file&gt;</span><br><span class="line"><span class="built_in">chown</span> mysql:mysql &lt;<span class="built_in">log</span> file&gt;</span><br></pre></td></tr></table></figure>



<h5 id="4-控制慢查询日志文件的权限"><a href="#4-控制慢查询日志文件的权限" class="headerlink" title="4) 控制慢查询日志文件的权限"></a>4) 控制慢查询日志文件的权限</h5><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录MySQL中查询时间超过（大于）设置阈值（long_query_time）的语句，记录到慢查询日志中。</p>
<p><strong>默认情况下，MySQL没有开启慢查询日志</strong>。需要手动打开，如果不是调优需要的话，不建议开启，因为开启会带来一定的性能影响，慢查询日志支持将日志记录写入文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启慢查询日志，只对当前数据库生效，并且重启数据库后失效</span><br><span class="line">set global slow_query_log = 1;</span><br></pre></td></tr></table></figure>

<p><strong>慢查询日志文件权限控制查看与设置：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mysql命令行下执行如下命令：</span></span><br><span class="line">show variables like <span class="string">&#x27;slow_query_log%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端命令行执行如下命令：</span></span><br><span class="line"><span class="built_in">ls</span> &lt;slow_query_log_file&gt;.*</span><br><span class="line"><span class="comment"># 对于发现的每一个文件，执行如下命令：</span></span><br><span class="line"><span class="built_in">ls</span> -l &lt;slow_query_log_file&gt; | egrep <span class="string">&quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span> </span><br><span class="line"><span class="comment"># 根据输出确认日志文件的权限设置是否存在问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于每个日志文件，修改其权限和属组如下：</span></span><br><span class="line"><span class="built_in">chmod</span> 660 &lt;<span class="built_in">log</span> file&gt;</span><br><span class="line"><span class="built_in">chown</span> mysql:mysql &lt;<span class="built_in">log</span> file&gt;</span><br></pre></td></tr></table></figure>



<h5 id="5-控制通用日志文件的权限"><a href="#5-控制通用日志文件的权限" class="headerlink" title="5) 控制通用日志文件的权限"></a>5) 控制通用日志文件的权限</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mysql命令行下执行如下命令：</span></span><br><span class="line">show variables like <span class="string">&#x27;general_log_file&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端命令行执行如下命令：</span></span><br><span class="line"><span class="built_in">ls</span> &lt;general_log_file&gt;.*</span><br><span class="line"><span class="comment"># 对于发现的每一个文件，执行如下命令：</span></span><br><span class="line"><span class="built_in">ls</span> -l &lt;general_log_file&gt; | egrep <span class="string">&quot;^-[r|w]&#123;2&#125;-[r|w]&#123;2&#125;----\s*.*$&quot;</span> </span><br><span class="line"><span class="comment"># 根据输出确认日志文件的权限设置是否存在问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于每个日志文件，修改其权限和属组如下：</span></span><br><span class="line"><span class="built_in">chmod</span> 660 &lt;<span class="built_in">log</span> file&gt;</span><br><span class="line"><span class="built_in">chown</span> mysql:mysql &lt;<span class="built_in">log</span> file&gt;</span><br></pre></td></tr></table></figure>



<h5 id="6-控制审计日志文件的权限"><a href="#6-控制审计日志文件的权限" class="headerlink" title="6) 控制审计日志文件的权限"></a>6) 控制审计日志文件的权限</h5><blockquote>
<h5 id="Naming-Conventions-for-Audit-Log-Files"><a href="#Naming-Conventions-for-Audit-Log-Files" class="headerlink" title="Naming Conventions for Audit Log Files"></a>Naming Conventions for Audit Log Files</h5><p>To configure the audit log file name, set the <a href="https://dev.mysql.com/doc/refman/8.0/en/audit-log-reference.html#sysvar_audit_log_file"><code>audit_log_file</code></a> system variable at server startup. The default name is <code>audit.log</code> in the server data directory. For best security, write the audit log to a directory accessible only to the MySQL server and to users with a legitimate reason to view the log.</p>
<p>[MySQL :: MySQL 8.0 Reference Manual :: 6.4.5.5 Configuring Audit Logging Characteristics](<a href="https://dev.mysql.com/doc/refman/8.0/en/audit-log-logging-configuration.html#:~:text=To">https://dev.mysql.com/doc/refman/8.0/en/audit-log-logging-configuration.html#:~:text=To</a> configure the audit log file name%2C set,with a legitimate reason to view the log.)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mysql命令行下执行如下命令：</span></span><br><span class="line">show global variables <span class="built_in">where</span> variable_name =  <span class="string">&#x27;audit_log_file&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端执行如下命令：</span></span><br><span class="line"><span class="built_in">ls</span> -l &lt;audit_log_file&gt; | egrep <span class="string">&quot;^-rw[-x]rw[-x][-r][-w][-x][ \t]*[0-9][ \t]*mysql[\t]*mysql.*$&quot;</span></span><br><span class="line"><span class="comment"># 根据输出确认日志文件的权限设置是否存在问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于每个日志文件，修改其权限和属组如下：</span></span><br><span class="line"><span class="built_in">chmod</span> 660 &lt;audit_log_file&gt;</span><br><span class="line"><span class="built_in">chown</span> mysql:mysql &lt;audit_log_file&gt;</span><br></pre></td></tr></table></figure>



<h3 id="8-1-4-4-入侵防范"><a href="#8-1-4-4-入侵防范" class="headerlink" title="8.1.4.4 入侵防范"></a><strong>8.1.4.4 入侵防范</strong></h3><p>本项要求包括：</p>
<p>a) 应遵循最小安装的原则，仅安装需要的组件和应用程序；</p>
<ul>
<li>核查测试数据库以及空账号</li>
</ul>
<p>b) 应关闭不需要的系统服务、默认共享和高危端口；</p>
<p>c) 应通过设定终端接入方式或网络地址范围对通过网络进行管理的管理终端进行限制；</p>
<ul>
<li>核查是否限制源IP访问</li>
</ul>
<p>d) 应提供数据有效性检验功能，保证通过人机接口输入或通过通信接口输入的内容符合系统设定要求；</p>
<p>e) 应能发现可能存在的已知漏洞，并在经过充分测试评估后，及时修补漏洞；</p>
<ul>
<li><del>核查是否及时打补丁</del></li>
</ul>
<p>f) 应能够检测到对重要节点进行入侵的行为，并在发生严重入侵事件时提供报警。</p>
<h4 id="核查测试数据库以及空账号"><a href="#核查测试数据库以及空账号" class="headerlink" title="核查测试数据库以及空账号"></a>核查测试数据库以及空账号</h4><h5 id="核查方式-11"><a href="#核查方式-11" class="headerlink" title="核查方式"></a>核查方式</h5><ul>
<li>查询数据库：<code>show DATABASES;</code></li>
<li>使用该命令查询是否存在空账号：<code>SELECT user,host FROM mysql.user WHERE user = &#39;&#39;; </code></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213101248151.png" alt="查询空用户名用户"></p>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213101419440.png" alt="查询数据库"></p>
<h5 id="加固方式-11"><a href="#加固方式-11" class="headerlink" title="加固方式"></a>加固方式</h5><p>删除测试数据库以及空账号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除冗余数据库, 如 test</span></span><br><span class="line">drop database <span class="keyword">if</span> exists <span class="variable">$&#123;dbname&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除无用用户（没有用户名的用户）</span></span><br><span class="line">drop user <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213101612486.png" alt="image-20221213101612486"></p>
<h4 id="核查是否限制源IP访问"><a href="#核查是否限制源IP访问" class="headerlink" title="核查是否限制源IP访问"></a>核查是否限制源IP访问</h4><blockquote>
<p>默认需要所有账号进行限制，不能存在 “<code>%</code> “ 任意源 <code>IP</code> 设置。</p>
</blockquote>
<h5 id="核查方式-12"><a href="#核查方式-12" class="headerlink" title="核查方式"></a>核查方式</h5><ul>
<li><code>SELECT user, host FROM mysql.user</code></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213000354563.png" alt="image-20221213000354563"></p>
<h5 id="加固方式-12"><a href="#加固方式-12" class="headerlink" title="加固方式"></a>加固方式</h5><ul>
<li><p>设置 <code>$&#123;账号&#125;</code> 指定源IP登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># update user set host=&#x27;$&#123;IP&#125;&#x27; where user=&#x27;root&#x27; and host=&#x27;%&#x27;;</span><br><span class="line"># 设置 root 用户只允许本地登录</span><br><span class="line">use mysql;</span><br><span class="line">update user set host=&#x27;localhost&#x27; where user=&#x27;root&#x27; and host=&#x27;%&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img data-src="/../images/harden-mysql/knowledge-baseimage-20221213000524679.png" alt="image-20221213000524679"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="安全标准"><a href="#安全标准" class="headerlink" title="安全标准"></a>安全标准</h3><ul>
<li><a href="http://c.gb688.cn/bzgk/gb/showGb?type=online&hcno=BAFB47E8874764186BDB7865E8344DAF"><strong>《信息安全技术  网络安全等级保护基本要求》</strong></a></li>
</ul>
<h3 id="产品文档"><a href="#产品文档" class="headerlink" title="产品文档"></a>产品文档</h3><ul>
<li><a href="https://dev.mysql.com/doc/">MySQL :: MySQL Documentation</a></li>
</ul>
<h3 id="博客文章"><a href="#博客文章" class="headerlink" title="博客文章"></a>博客文章</h3><ul>
<li><a href="https://blog.csdn.net/Lee_Natuo/article/details/83995418">(100条消息) MySQL数据库安全加固方法_Lee_Natuo的博客-CSDN博客</a></li>
<li><a href="https://cloud.tencent.com/developer/article/2115190">MySQL8.0正确修改密码的姿势- 腾讯云开发者社区-腾讯云 (tencent.com)</a></li>
<li><a href="https://blog.csdn.net/liliuqing/article/details/88723409">(100条消息) mysql8.0.15用户root登录开启远程访问权限_藤叶香来的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_40147863/article/details/86485439">(100条消息) MySQL 8.0 版本授权 root 远程连接，修改权限，更改加密方式_肖朋伟的博客-CSDN博客_mysql8.0更改root 权限</a></li>
<li>[(100条消息) Linux系统中，Mysql 8的安装、修改root密码及允许root远程登录_时栈的博客-CSDN博客_mysql8允许root远程连接](<a href="https://blog.csdn.net/qq_44667259/article/details/123228144#:~:text=%E4%B8%80%E3%80%81CentOS%E7%B3%BB%E7%BB%9F%E4%B8%ADMysql">https://blog.csdn.net/qq_44667259/article/details/123228144#:~:text=一、CentOS系统中Mysql</a> 8的安装 1 1.安装 sudo yum install mysql-,user from user where user%3D’root’%3B %2F%2F 查看 )</li>
<li><a href="https://blog.csdn.net/weixin_35067439/article/details/113159734">(100条消息) mysql8.0 删除用户_MYSQL8 创建、删除用户和授权、消权操作_番茄君小弟的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_23859799/article/details/85862821">(100条消息) mysql8.0数据库添加用户和授权_liuzh2443的博客-CSDN博客_mysql8用户授权</a></li>
<li><a href="https://blog.csdn.net/weixin_27017211/article/details/113113357">(100条消息) mysql8.0 新增用户_MySQL8.0添加创建用户、删除用户与授权(create user，delete user)_故事档案局的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/weixin_35750747/article/details/113155504">(100条消息) mysql connect 超时_MySQL修改connect_timeout（连接超时）全局变量_半清斋的博客-CSDN博客</a></li>
<li><a href="https://www.jianshu.com/p/d14377a57d3a">MySQL修改connect_timeout（连接超时）全局变量 - 简书 (jianshu.com)</a></li>
<li>[(100条消息) mysql 5.7 连接超时参数设置_大龄奋斗程序猿的博客-CSDN博客_mysql 5.7配置超时](<a href="https://blog.csdn.net/aichogn/article/details/118113114#:~:text=connect_timeout%E6%8C%87%E7%9A%84%E6%98%AF%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%8F%A1%E6%89%8B%E7%9A%84%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%2C%E5%9C%A8">https://blog.csdn.net/aichogn/article/details/118113114#:~:text=connect_timeout指的是连接过程中握手的超时时间%2C在</a> 5.0.52 以后默认为,10 秒，之前版本默认是 5 秒。)</li>
<li><a href="https://blog.csdn.net/weixin_42586723/article/details/121057330">(100条消息) MySQL学习之三级等保整改_Charles Yan的博客-CSDN博客_mysql 等保</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1173009">设置Mysql的连接超时参数wait_timeout、interactive_timeout - 腾讯云开发者社区-腾讯云 (tencent.com)</a></li>
<li><a href="https://blog.csdn.net/xtaypyvi123456/article/details/125274821">(100条消息) Linux MySQL5.7等保问题整改：数据库未配置登录失败处理功能，未配置非法登录策略和登录超时自动退出功能。_可爱的小张666的博客-CSDN博客_mysql超时自动退出功能。</a></li>
<li><a href="https://blog.csdn.net/weixin_33622153/article/details/115906282">(100条消息) mysql多次登录失败控制,Mysql登录失败多次锁定配置_Luna Li的博客-CSDN博客</a></li>
<li><a href="https://www.cnblogs.com/windysai/p/15996858.html">mysql密码策略和登录失败处理 - windysai - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/weixin_39762666/article/details/113627025">(100条消息) mysql 修改登录失败处理功能参数_等保测评2.0：MySQL身份鉴别_weixin_39762666的博客-CSDN博客</a></li>
<li><a href="https://www.cnblogs.com/mysqljs/p/14246130.html">MySQL密码复杂度与密码过期策略介绍 - MySQL技术 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://www.jianshu.com/p/4ac3cb49d208">mysql查看密码自动过期时间 - 简书 (jianshu.com)</a></li>
<li><a href="https://blog.csdn.net/andyguan01_2/article/details/88966432">(100条消息) MySQL关闭SSL的方法_andyguan01_2的博客-CSDN博客_mysql关闭openssl</a></li>
<li><a href="https://www.jianshu.com/p/63ba67e133ce">配置MySQL支持ssl - 简书 (jianshu.com)</a></li>
<li><a href="https://blog.csdn.net/qq_39572257/article/details/116227265">(100条消息) MySQL配置SSL加密连接_guan-qing的博客-CSDN博客_navicate ssl连接</a></li>
<li><a href="https://blog.csdn.net/Lee_Natuo/article/details/84856377">(100条消息) MySQL数据库安全基线（加固方法）_Lee_Natuo的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/weixin_36340926/article/details/113256066">(106条消息) mysql永久修改变量_MySQL 8.0 新特性之持久化全局变量的修改_实在知道什么的博客-CSDN博客</a></li>
</ul>
<h3 id="持久化全局变量"><a href="#持久化全局变量" class="headerlink" title="持久化全局变量"></a>持久化全局变量</h3><p>全局变量的持久化命令</p>
<p>1） <code>SET PERSIST</code> </p>
<ul>
<li>修改内存值，将全局变量的修改持久化到配置文件中</li>
<li>只需要 <code>SYSTEM_VARIABLES_ADMIN</code></li>
</ul>
<p>2）<code>SET PERSIST_ONLY</code></p>
<ul>
<li>只持久化全局变量，而不修改其内存值</li>
<li>需要 <code>SYSTEM_VARIABLES_ADMIN</code> 和 <code>PERSIST_RO_VARIABLES_ADMIN</code> 权限</li>
</ul>
<p>3）<code>set persist max_connections=default;</code></p>
<ul>
<li><p>将全局变量持久化为默认值。注意，是默认值，而不是修改前的值。</p>
</li>
<li><p>这个命令同 <code>set global max_connections=default</code> 类似，都会将变量的值设置为默认值，只不过前者还会将默认值持久化到配置文件中。</p>
</li>
</ul>
<p>清除持久化变量命令</p>
<p>1）<code>RESET PERSIST</code> </p>
<ul>
<li>注意，其只是清空 <code>mysqld-auto.cnf</code> 和 <code>performance_schema.persisted_variables</code> 中的内容，对于已经修改了的变量的值，不会产生任何影响。</li>
</ul>
<h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 核查是否开启加密通信</span><br><span class="line">show variables like &#x27;have_openssl&#x27;;</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%ssl%&#x27;;</span><br><span class="line"></span><br><span class="line"># 设置为0，即表示密码永不过期</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%default_password_lifetime%&#x27;; </span><br><span class="line">SET GLOBAL default_password_lifetime = 90;</span><br><span class="line"></span><br><span class="line">show variables like &#x27;validate%&#x27;; </span><br><span class="line">INSTALL PLUGIN validate_password SONAME &#x27;validate_password.dll&#x27;;</span><br><span class="line">set global validate_password_length = 16;</span><br><span class="line"></span><br><span class="line">show variables like &#x27;%connection_control%&#x27;;</span><br><span class="line">install plugin CONNECTION_CONTROL soname &#x27;connection_control.dll&#x27;;</span><br><span class="line">install plugin CONNECTION_CONTROL_FAILED_LOGIN_ATTEMPTS soname &#x27;connection_control.dll&#x27;;</span><br><span class="line">SET GLOBAL connection_control_failed_connections_threshold = 5;</span><br><span class="line">SET GLOBAL connection_control_min_connection_delay = 900000;</span><br><span class="line"></span><br><span class="line"># 查看已安装插件</span><br><span class="line">show plugins;</span><br><span class="line"></span><br><span class="line">show global variables like &#x27;%timeout%&#x27;;</span><br><span class="line">set global connect_timeout = 43200;</span><br><span class="line">set global wait_timeout=28800;</span><br><span class="line">set global interactive_timeout=28800;</span><br><span class="line"></span><br><span class="line">SELECT user, host FROM mysql.user;</span><br><span class="line">create user &#x27;dev&#x27;@&#x27;localhost&#x27; identified by &#x27;Haiyisec@123&#x27;; </span><br><span class="line">create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;Haiyisec@123&#x27;; </span><br><span class="line">drop user &#x27;test&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">drop user &#x27;dev&#x27;@&#x27;localhost&#x27;;</span><br><span class="line"></span><br><span class="line"># 设置只允许root用户本地登录</span><br><span class="line">use mysql;</span><br><span class="line">update user set host=&#x27;localhost&#x27; where user=&#x27;root&#x27; and host=&#x27;%&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"># 重命名账号</span><br><span class="line">update user set user=&#x27;haiyi_root&#x27; where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">SELECT user, host FROM mysql.user;</span><br><span class="line"></span><br><span class="line"># 实验时出现问题，更新后无法登录，谨慎操作</span><br><span class="line">UPDATE user SET authentication_string=&quot;123456&quot; WHERE user=&quot;root&quot;;</span><br><span class="line">FLUSH privileges;</span><br><span class="line"></span><br><span class="line">show variables like &#x27;%log%&#x27;;</span><br><span class="line">show variables like &#x27;slow_query_log%&#x27;;</span><br><span class="line">SHOW variables LIKE &#x27;log_error&#x27;;</span><br><span class="line">SELECT @@global.log_bin_basename;</span><br><span class="line">set global general_log=on;</span><br><span class="line"></span><br><span class="line">set global binlog_expire_logs_seconds=2596096;</span><br><span class="line">show variables like &#x27;binlog_expire_logs_seconds&#x27;;</span><br><span class="line">show variables where variable_name = &#x27;datadir&#x27;; </span><br><span class="line"></span><br><span class="line">SELECT user,host FROM mysql.user WHERE user = &#x27;&#x27;;</span><br><span class="line">CREATE DATABASE test;</span><br><span class="line">DROP DATABASE if EXISTS test;</span><br><span class="line">show DATABASES;</span><br><span class="line"></span><br><span class="line"># 查看指定用户权限</span><br><span class="line">SHOW GRANTS FOR &#x27;root&#x27;@&#x27;localhost&#x27;;</span><br><span class="line"># 查看所有用户详细信息</span><br><span class="line">SELECT * FROM mysql.user;</span><br><span class="line"># 查看所有数据库详细</span><br><span class="line">SELECT * FROM mysql.Db;</span><br><span class="line"></span><br><span class="line"># 如下语句查询是否有用户不需要密码即可登录：</span><br><span class="line">select * from mysql.user where length(authentication_string)=0 or authentication_string is null;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基线核查与加固</category>
      </categories>
      <tags>
        <tag>基线核查与加固</tag>
        <tag>mysql</tag>
        <tag>网络安全等级保护基本要求</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7 下安装 Python3.8.5</title>
    <url>/2023/09/02/setup-python3-8-5/</url>
    <content><![CDATA[<h1 id="一、前置条件"><a href="#一、前置条件" class="headerlink" title="一、前置条件"></a>一、前置条件</h1><h2 id="1）安装依赖"><a href="#1）安装依赖" class="headerlink" title="1）安装依赖"></a>1）安装依赖</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install libffi-devel zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make</span><br></pre></td></tr></table></figure>

<h2 id="2）更新-openssl"><a href="#2）更新-openssl" class="headerlink" title="2）更新 openssl"></a>2）更新 openssl</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate   https://www.openssl.org/source/openssl-1.1.1t.tar.gz</span><br><span class="line">tar -zxvf openssl-1.1.1t.tar.gz</span><br><span class="line"><span class="built_in">cd</span> openssl-1.1.1t/</span><br><span class="line">./config --prefix=/usr/local/my_openssl</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> /usr/bin/openssl /usr/bin/oldopenssl</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/my_openssl/bin/openssl /usr/bin/openssl</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/my_openssl/lib/libssl.so.1.1 /usr/lib64/</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/my_openssl/lib/libcrypto.so.1.1  /usr/lib64/</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="二、下载解压"><a href="#二、下载解压" class="headerlink" title="二、下载解压"></a>二、下载解压</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.huaweicloud.com/python/3.8.5/Python-3.8.5.tgz</span><br><span class="line"></span><br><span class="line">tar -zxvf Python-3.8.5.tgz</span><br></pre></td></tr></table></figure>

<h1 id="三、编译安装"><a href="#三、编译安装" class="headerlink" title="三、编译安装"></a>三、编译安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Python-3.8.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接到新版本OpenSSL</span></span><br><span class="line">./configure --with-openssl=/usr/local/my_openssl  --prefix=/usr/local/python3</span><br><span class="line"></span><br><span class="line">make clean &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h1 id="四、配置环境变量并创建软连接"><a href="#四、配置环境变量并创建软连接" class="headerlink" title="四、配置环境变量并创建软连接"></a>四、配置环境变量并创建软连接</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/profile</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PYTHON_HOME=/usr/local/python3</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PYTHON_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建软连接</span></span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/python3/bin/python3.8 /usr/bin/python3</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/python3/bin/pip3.8 /usr/bin/pip3</span><br></pre></td></tr></table></figure>

<h1 id="五、配置清华源"><a href="#五、配置清华源" class="headerlink" title="五、配置清华源"></a>五、配置清华源</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<h1 id="六、测试"><a href="#六、测试" class="headerlink" title="六、测试"></a>六、测试</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 python 版本</span></span><br><span class="line">python3 -V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 pip 版本</span></span><br><span class="line">pip3 -V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 python 环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PYTHON_HOME</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>pyspark</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>域名缓存侦测技术</title>
    <url>/2023/06/15/%E5%9F%9F%E5%90%8D%E7%BC%93%E5%AD%98%E4%BE%A6%E6%B5%8B%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="技术说明"><a href="#技术说明" class="headerlink" title="技术说明"></a>技术说明</h1><p>域名缓存探测技术是一种用于获取目标系统 DNS 缓存信息的技术。通过发送特定的 DNS 查询请求并观察响应时间和内容，可以推断出目标系统是否存在特定域名的 DNS 缓存记录。</p>
<span id="more"></span>

<p>例如，测试人员可以提交某安全软件更新所使用的域名，如果有记录，说明该网络使用该种安全软件。</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dns.message</span><br><span class="line"><span class="keyword">import</span> dns.rdatatype</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DNSCacheSnooping</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.dns_server = <span class="string">&#x27;8.8.8.8&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_dns_server</span>(<span class="params">self, nameserver=<span class="string">&#x27;8.8.8.8&#x27;</span></span>):</span><br><span class="line">        self.dns_server = nameserver</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detect</span>(<span class="params">self, domain</span>):</span><br><span class="line">        <span class="comment"># 创建 UDP 套接字</span></span><br><span class="line">        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置超时时间</span></span><br><span class="line">        sock.settimeout(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造 DNS 请求数据包</span></span><br><span class="line">        query = dns.message.make_query(domain, dns.rdatatype.A, dns.rdataclass.IN)</span><br><span class="line">        query.flags &amp;= ~dns.flags.RD</span><br><span class="line">        <span class="comment"># query.flags |= dns.flags.RD</span></span><br><span class="line"></span><br><span class="line">        sock.sendto(query.to_wire(), (self.dns_server, <span class="number">53</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 接收 DNS 响应数据包</span></span><br><span class="line">            data, _ = sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 解析 DNS 响应数据包</span></span><br><span class="line">            response = dns.message.from_wire(data)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取解析结果</span></span><br><span class="line">            answers = response.answer</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(answers) == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;No Cache for [<span class="subst">&#123;domain&#125;</span>] in [<span class="subst">&#123;self.dns_server&#125;</span>]&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> ans <span class="keyword">in</span> answers:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&#x27;Find Cache: [<span class="subst">&#123;ans&#125;</span>] in [<span class="subst">&#123;self.dns_server&#125;</span>]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> socket.timeout:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;DNS query timeout&quot;</span>)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 关闭套接字</span></span><br><span class="line">            sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;A simple command-line tool&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--domain-file&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;domains in file&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;--domain&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;single domain&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-s&#x27;</span>, <span class="string">&#x27;--dns-server&#x27;</span>, default=<span class="string">&#x27;8.8.8.8&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;A dns server&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    detector = DNSCacheSnooping()</span><br><span class="line">    <span class="keyword">if</span> args.dns_server:</span><br><span class="line">        detector.set_dns_server(args.dns_server)</span><br><span class="line">    <span class="keyword">if</span> args.domain:</span><br><span class="line">        detector.detect(domain=args.domain)</span><br><span class="line">    <span class="keyword">if</span> args.domain_file:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(args.domain_file):</span><br><span class="line">            args.domain_file = os.path.join(os.getcwd(), args.domain_file)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(args.domain_file) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> domain <span class="keyword">in</span> <span class="built_in">list</span>(f):</span><br><span class="line">                <span class="keyword">if</span> domain.strip() != <span class="string">&quot;&quot;</span>:</span><br><span class="line">                    detector.detect(domain=domain.strip())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="单域名测试"><a href="#单域名测试" class="headerlink" title="单域名测试"></a>单域名测试</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(venv) ➜  info-tools git:(main) ✗ python test_DNS_Cache_Snooping.py -d example.com -s 114.114.114.114</span><br><span class="line">DNS query <span class="built_in">timeout</span></span><br></pre></td></tr></table></figure>



<h1 id="多域名文件测试"><a href="#多域名文件测试" class="headerlink" title="多域名文件测试"></a>多域名文件测试</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># domains.txt</span></span><br><span class="line"><span class="comment"># 每行一个域名</span></span><br><span class="line">example.com</span><br><span class="line">baidu.com</span><br><span class="line">google.com</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(venv) ➜  info-tools git:(main) ✗ python test_DNS_Cache_Snooping.py -f domains.txt -s 114.114.114.114</span><br><span class="line">No Cache <span class="keyword">for</span> [example.com] <span class="keyword">in</span> [114.114.114.114]</span><br><span class="line">DNS query <span class="built_in">timeout</span></span><br><span class="line">DNS query <span class="built_in">timeout</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>domain</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7 下安装 Jupyter</title>
    <url>/2023/09/02/setup-jupyter/</url>
    <content><![CDATA[<h1 id="JupyterLab"><a href="#JupyterLab" class="headerlink" title="JupyterLab"></a>JupyterLab</h1><p>Install JupyterLab with pip:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install jupyterlab</span><br></pre></td></tr></table></figure>

<p>Once installed, launch JupyterLab with:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jupyter lab</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h1><p>Install the classic Jupyter Notebook with:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install notebook</span><br></pre></td></tr></table></figure>

<p>To run the notebook:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>

<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. generate config</span></span><br><span class="line">jupyter lab --generate-config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. change settings</span></span><br><span class="line">c.ServerApp.ip = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">c.ServerApp.open_browser = False</span><br><span class="line">c.ServerApp.allow_remote_access = True</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. open port</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8888/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>pyspark</tag>
        <tag>jupyterlab</tag>
      </tags>
  </entry>
</search>
